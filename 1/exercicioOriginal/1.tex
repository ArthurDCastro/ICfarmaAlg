\item Faça  um programa que leia e  armazene em um vetor  uma sequência de
inteiros.  Em seguida  o programa  deve  ler uma  sequência de  inteiros
informados pelo usuário e, para cada  um deles, dizer se ele pertence ou
não ao vetor armazenado previamente. 

\item Faça um  programa que  leia duas  sequências de  $n$ inteiros  em dois
vetores distintos,  digamos, $v$ e  $w$ e verifique  se os dois  vetores são
idênticos. 

\item Faça um programa em  que leia dois vetores de números reais
e descubra se um deles é permutação do outro, isto é, se eles
tem os mesmos elementos, ainda que em ordem diferente.
A quantidade de elementos lidos em cada vetor é no  máximo 100,  e
cada sequência termina quando o valor 0 é digitado. 
Por   exemplo: 

        $[2,2,0,3,4]$   e  $[2,2,0,3,4]$:   sim.
  
        $[2,2,0,3,4]$ e  $[4,3,2,0,2]$: sim.
        
        $[2,2,0,3,4]$ e $[4,3,4,0,2]$: não. 
        
        $[3,0,5]$ e $[3,0,5,3]$: não.

Implemente três
versões deste problema:
\begin{itemize}
\item ordenando os vetores para em seguida compará-los;
\item sem ordenar os vetores;
\item crie uma
 função que  retorna  0 se $x$  não  pertence a  $v$ e  caso contrário
 retorna o índice  do vetor onde  $x$  se encontra. Use esta função para 
 resolver este problema. 
\end{itemize}




\item Faça  um  programa  que   leia  duas  sequências  de  inteiros,  não
necessariamente  contendo a  mesma quantidade  de números. Seu programa
deverá:
\begin{itemize} 
\item dizer  se a segunda sequência está contida na primeira. Exemplo:
\begin{verbatim}
v1: 7 3 2 3 2 6 4 7 
v2: 3 2 6
Saída: sim
\end{verbatim}
\item construir um terceiro  vetor, sem  destruir os  originais, que é  
      a concatenação  do primeiro com o segundo;
\begin{verbatim}
v1: 7 3 2 6
v2: 5 1 8 4 9
Saída: 1 2 3 4 5 6 7 8 9
\end{verbatim}
\item ordená-los, e em seguida imprimir todos os números ordenados 
      em ordem crescente. Exemplo:
\begin{verbatim}
v1: 7 3 2 6
v2: 5 1 8 4 9
Saída: 1 2 3 4 5 6 7 8 9
\end{verbatim}
\end{itemize}

\item Crie uma função que receba um vetor de inteiros de 
     tamanho $n$ e devolva o valor \emph{true} se o vetor estiver ordenado e 
     \emph{false} em caso contrário.

\item Aproveitando as soluções dos problemas anteriores, escreva um programa
     que leia dois vetores de inteiros $v$ e $w$, 
     de dimensões $m$ e $n$ 
     respectivamente, verifique se eles estão ordenados, ordene-os em caso 
     contrário e, em seguida, imprima a intercalação dos dois. \\
     Exemplo de intercalação: $v$: 1 4 6 9; $w$: 2, 3, 5, 7. \\
     Saída: 1, 2, 3, 4, 5, 6, 7, 9. 

\item Dados dois números naturais $m$ e $n$, uma frase com $m$ letras
e uma palavra com $n$ letras, escreva um procedimento que determine o número de
vezes que a palavra ocorre na frase e a posição em que cada ocorrência inicia.

    Exemplo:
    \begin{verbatim}
    Para M = 30, N = 3, a palavra ANA e a frase:
        ANA E MARIANA GOSTAM DE BANANA
    A palavra ANA ocorre 4 vezes, nas posições 1, 11, 26, 28.
    \end{verbatim}

\item Dada uma sequência de $N$ números, determinar quantos números dintintos
compõe  a sequência e  o número  de vezes  que cada  um deles  ocorre na
mesma. Exemplo:

N=5
1 2 3 2 3 
a sequência tem três números distintos, 1, 2 e 3. Ocorrências:
1 ocorre 1 vez
2 ocorre 2 vezes
3 ocorre 2 vezes

\item Dadas  duas  sequências  com  $n$  números  inteiros  entre  0  e  1,
interpretados como números binários:
\begin{enumerate}
     \item imprimir o valor decimal dos números;
     \item calcular a soma de ambos (em binário), usando o ``vai-um'';
     \item imprimir o valor decimal da soma.
\end{enumerate}


\item Escreva um programa em  que leia os seguintes valores:
um inteiro $B$, um inteiro $N$ ($1 \leq N \leq 10$), e $N$ valores inteiros.
A ideia é que estes valores sejam entendidos como a representação
de um número não negativo na base $B$. 
Estes valores deverão ser inseridos em um vetor de tamanho $N+1$, onde
a primeira posição armazena a base $B$ e as outras $N$ posições
o restante dos números lidos. 
%
Note que o  intervalo de valores possíveis para cada dígito na
base $B$ é $[0, B-1]$.
%
Seu programa deve retornar o valor em decimal do número representado
no vetor. Se o número representado no vetor não for válido na
base $B$ então deverá ser retornado o código de erro ``-1''.
Por exemplo, se $B=3$ o número 2102 na base 3 equivale ao valor decimal 65;
se $B=4$ o número $35$ é inválido na base 4.


\item Faça um programa que, 
dadas duas sequências com
$N$ números inteiros entre 0 e 9, interpretadas como dois números
inteiros de $N$ algarismos, calcular a sequência de números que
representa a soma dos dois inteiros, usando o ``vai-um''. Por exemplo:\\

\verb|        N=6,|\\
\verb|                4 3 4 2 5 1|\\
\verb|              + 7 5 2 3 3 7|\\
\verb|              1 1 8 6 5 8 8|



\item Dada  uma  sequência  $x_1$,  $x_2$, \ldots,  $x_n$  de  
números  inteiros,
determinar um segmento de soma  máxima.  Exemplo: na sequência 5, 2, -2,
-7, 3, 14,  10, -3, 9, -6, 4,  1, a soma do maior segmento  é 33, obtida
pela soma dos números de 3 até 9. 
 
\item Implemente um programa que leia um vetor de 1 milhão de inteiros
   em um vetor de inteiros. Gere um número aleatório e o procure
   neste vetor de duas maneiras diferentes: uma usando busca com 
   sentinela e outra usando busca binária. Seu programa deve imprimir
   uma tabela com o número de comparações feitas em cada um dos casos
   acima (busca com sentinela e busca binária). Desconsidere o tempo
   gasto com ordenação no caso da busca binária. A busca com sentinela
   deve ser feita em um vetor não ordenado. Gere 200 números aleatórios
   e imprima a média de comparações para cada um dos dois algoritmos
   sendo testados.

\item 
Suponha que um ex\'ercito tenha 20 regimentos e que eles est\~ao em processo
de forma\c c\~ao. Inicialmente o primeiro tem 1000 homens, o segundo 950,
o terceiro 900, e assim por diante, at\'e o vig\'esimo que tem 50. Suponhamos
que a cada semana 100 homens s\~ao enviados para cada regimento, e no final
da semana o maior regimento \'e enviado para o {\em front}. Imaginemos que o
general do quinto regimento \'e companheiro de xadrez do comandante supremo,
e que eles est\~ao no meio de uma partida. O comandante supremo ent\~ao
envia apenas 30 homens para o quinto regimento a cada semana, esperando com
isto poder acabar o jogo com seu colega.
Escreva um programa em 
que diga, a cada semana, qual \'e o regimento enviado ao {\em front} e mostre o {\em status} dos outros regimentos. O programa
deve tamb\'em determinar exatamente quantas semanas levar\'a o quinto regimento
para ser deslocado ao {\em front}. 

\item Suponha que voc\^e esteja usando o m\'etodo da ordenação 
por sele\c c\~ao. Qual das sequências abaixo requerir\'a o menor n\'umero
de trocas? Quantas? Qual requerir\'a o maior n\'umero de trocas? Quantas?
Explique.
\begin {enumerate}
\item 10, 9, 8, 7, 6, 5, 4, 3, 2, 1.
\item 5, 4, 3, 2, 1, 10, 9, 8, 7, 6.
\item 10, 1, 9, 2, 8, 3, 7, 4, 6, 5.
\item 2, 3, 4, 5, 6, 7, 8, 9, 10, 1.
\item 1, 10, 2, 9, 3, 8, 4, 7, 5, 6.
\end {enumerate}

\item Suponha que voc\^e tem uma vari\'avel do tipo vetor declarada como:
\emph{array [1..50] of real;}. 
Fa\c ca uma fun\c c\~ao 
que inicialize o vetor de modo que os elementos
de \'{\i}ndices \'{\i}mpares recebam o valor inicial -2.0 e os elementos
de \'{\i}ndices pares recebam o valor inicial 7.0. Sua função deve
fazer uso de um único comando de repetição, que incrementa de um em um, e de 
nenhum comando de desvio condicional.

\item Qual dos seguintes problemas requer o uso de vetores para uma solu\c c\~ao elegante?
\begin {enumerate}
\item Ler cerca de duzentos n\'umeros e imprimir os que est\~ao em uma certa faixa;
\item Computar a soma de uma sequ\^encia de n\'umeros;
\item Ler exatamente duzentos n\'umeros e orden\'a-los em ordem crescente;
\item Encontrar o segundo menor elemento de uma sequ\^encia de entrada;
\item Encontrar o menor inteiro de uma sequ\^encia de inteiros.
\end {enumerate}

\item Considere um vetor  declarado como: 
\emph{array [1..50] of integer} que tem a 
particularidade de todos os elementos estarem entre 1 e 30, sendo que
nenhum \'e repetido. Fa\c ca um programa
que ordene o vetor de maneira eficiente explorando esta característica e fazendo
o menor n\'umero poss\'{\i}vel de trocas.

\item   Dada uma sequência $x_1, x_2, \ldots, x_k$ de números
  reais, verifique  se existem dois segmentos  consecutivos iguais nesta
  sequência, isto é, se existem $i$ e $m$ tais que:
\[ x_i, x_{i+1}, \ldots, x_{i+m-1}=x_{i+m}, x_{i+m+1}, \ldots, x_{i+2m-1}.
\]
Imprima, caso existam,  os valores de $i$ e de  $m$. Caso contrário, não
imprima  nada. Exemplo:  Na sequência  7,9,5,4,5,4,8,6, existem  $i=3$ e
$m=2$. 

\item   Um coeficiente binomial, geralmente denotado
  $\binom{n}{k}$, representa o número de possíveis combinações de $n$
  elementos tomados $k$ a $k$. Um ``Triângulo de Pascal'', uma homenagem
  ao grande matemático Blaise Pascal, é uma tabela de valores de
  coeficientes combinatoriais para pequenos valores de $n$ e $k$. Os
  números que não são mostrados na tabela têm valor zero. Este triângulo
  pode ser construído automaticamente usando-se uma propriedade
  conhecida dos coeficientes binomiais, denominada ``fórmula da
  adição'':
$\binom{r}{k} = \binom{r-1}{k} + \binom{r-1}{k-1}.$
Ou seja, cada elemento do triângulo é a soma de dois elementos da linha
anterior, um da mesma coluna e um da coluna anterior. 
Veja  um  exemplo de  um  triângulo  de Pascal  com  7  linhas:
\[\begin{array}{ccccccc}
1 \\
1 & 1 \\
1 & 2 & 1 \\
1 & 3 & 3 & 1 \\
1 & 4 & 6 & 4 & 1 \\
1 & 5 & 10 & 10 & 5 & 1 \\
1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{array}
\]
Faça um programa que imprima na tela um triângulo de Pascal
com 10 linhas.  Seu programa deve obrigatoriamente fazer uso de
exatamente dois vetores durante o processo de construção. Um deles
conterá a última linha ímpar gerada, enquanto que o outro conterá a
última linha par gerada. Lembre-se que os elementos que não aparecem na
tabela tem valor nulo. Você deve sempre ter o controle do tamanho da
última linha impressa (o tamanho útil dos vetores em cada passo). Você
deve também usar um procedimento para imprimir o vetor. Observe que não
há entrada de dados, os dois vetores são gerados, um a partir do outro.
O único elemento da primeira linha tem o valor 1. Você deve
obrigatoriamente declarar um tipo vetor com tamanho máximo
Tam\_max\_vetor, e o seu programa deverá tomar cuidado para manipular
corretamente vetores de tamanho menor do que o tamanho máximo, impedindo
que haja uma atribuição em posição ilegal de memória. 


\item Resolva o problema do triângulo de Pascal usando somente um vetor.

\item Seja um polinômio $p(x)= a_0 + a_1 x + a_2 x^2 + \ldots + a_n x^n$ de
  grau $n \ge 2$. Uma possível maneira de calcular uma raiz do polinômio
  é pelo ``método de Newton''. Este método consiste em se fornecer uma
  aproximação inicial para a raiz, isto é, um valor que não é a raiz
  exata, mas é um valor próximo.  Assim, se $x_0$ é esta
  aproximação inicial, $p(x_0)$ não é zero mas espera-se que
  seja próximo de zero.  A obtenção da raiz pelo método de Newton é
  feita pelo refinamento desta solução inicial, isto é, pela tentativa
  de minimizar o erro cometido. Isto é feito pela expressão seguinte:
\[x_{n+1}=x_{n}-\frac{p(x_{n})}{p\prime(x_{n})},\]  $n=0,1,2,\ldots$,  e
  onde $p\prime(x)$ é a primeira derivada de $p(x$). Usualmente, repete-se
  este refinamento até que $|x_{n+1}-x_{n}| < \epsilon, \epsilon>0$, ou
  até que $m$ iterações tenham sido executadas. \\
  Construa um programa em  que receba como dados de entrada 
  um polinômio $p(x)= a_0 + a_1 x + a_2 x^2 + \ldots + a_n x^n$ e
  uma  aproximação inicial  $x_0$ da  raiz de  $p(x)$, $\epsilon>0$  e o
  número  máximo de  iterações, e  calcule  uma aproximação  da raiz  de
  $p(x)$ pelo método de Newton. Utilize obrigatoriamente um procedimento
  que receba como parâmetro  um polinômio $p(x)$ (incluindo a informação
  sobre o grau do polinômio) e que calcule e retorne a função
  derivada  $p\prime(x)$.  Utilize também  uma  função  que receba  como
  parâmetros um polinômio $p(x)$ e um valor real $\overline{x}$ e retorne
  o   valor    do   polinômio    no   ponto   $\overline{x}$,    isto   é
  $p(\overline{x})$. Use  esta função para  calcular, a cada  iteração do
  método    de    Newton,    os    valores   de    $p(x_{n})$    e    de
  $p\prime(x_{n})$.  

\item Faça um programa em  que leia uma sequência de 10 
     letras (caracteres de A a Z), as armazene em um vetor de 10 posições 
     e imprima a lista de letras repetidas no vetor. Sendo assim, para os 
     dados: A J G A D F G A A, a saída deve ser: A G.

\item Escreva o programa da busca binária de um valor $x$ num 
     vetor de inteiros que, ao invés de achar a primeira ocorrência do valor 
     na lista, identifique e imprima o menor índice do vetor no qual o valor 
     ocorra.

\item Escreva um programa que leia uma sequência de {\em código de
operação} e {\em valor}, onde o {\em código de operação} é um inteiro com
os seguintes valores:
\begin{itemize}
\item 0 (zero): fim
\item 1 (um): inserção
\item 2 (dois): remoção
\end{itemize} 

O {\em valor} lido é um real que deve ser inserido em um vetor (caso a
operação seja 1), ou removido do vetor (caso a operação seja 2).   As
inserções no vetor devem ser realizadas de forma que o vetor esteja sempre
ordenado.   No final do programa o vetor resultante deve ser impresso.

Detalhamento:
\begin{itemize}
\item a quantidade máxima de valores que pode  ser inserida é 100;
\item se a quantidade máxima for ultrapassada o programa deve dar uma
mensagem de erro;
\item se for requisitada a remoção de um número não existente o programa
  deve dar uma mensagem de erro;
\item se o código de operação for inválido o programa deve continuar lendo
um novo código até que ele seja 0 (zero), 1 (um) ou 2 (dois).
\end{itemize}

\noindent
{\bf Exemplo de execução: }
\begin{small}
\begin{verbatim}
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 45.3 
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 34.3 
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 40.8
Entre com operacao (0=fim, 1=insercao, 2=remocao): 2 
Valor: 34.3
Entre com operacao (0=fim, 1=insercao, 2=remocao): 0
Vetor resultante
40.8   45.3 
\end{verbatim}
\end{small}

\begin{center}
\begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|l}
\multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \\ \cline{1-6} 
&&&&&& \mbox{início}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
45.3&&&&&& \mbox{após inserção de 45.3}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
34.3&45.3&&&&& \mbox{após inserção de 34.3}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
34.3&40.8&45.3&&&& \mbox{após inserção de 40.8}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
40.8&45.3&&&&& \mbox{após remoção de 34.3}\\ \cline{1-6}
\end{tabular}
\end{center}

\item Escreva um programa 
que leia duas sequências de caracteres e
verifica se a segunda sequência é subpalavra da primeira.
Por exemplo, {\em todo} é subpalavra de {\em metodo} e
{\em ar} é subpalavra de {\em farmacia}.  Porém, {\em todo} não é
subpalavra de {\em todavia}.   A leitura das sequências deve ser feita
caracter por caracter e o final de cada sequência é sinalizada pelo
caracter '.'.    Se a segunda sequência é uma subpalavra, a saída do 
programa deve ser a posição na qual ela começa.  Caso contrário, escrever
a mensagem ``Nao eh subpalavra.''. 
{Observações:} 
\begin{itemize}
\item cada sequência tem no máximo 80 caracteres.
\item você não pode utilizar funções de manipulação de cadeias de
caracteres existentes no compilador, mas somente as funções para o
tipo {\tt char}.
\end{itemize}

\noindent
{Exemplo de execução: }
\small
\begin{verbatim}
Entre com duas palavras terminadas por ponto:
metodo.todo.

A segunda subpalavra comeca na posicao 3 da primeira.
\end{verbatim}



\item Escreva um programa que leia uma sequência de $n$ valores
reais ($n \leq 100$) e os insira num vetor.  A sequência termina quando o
valor lido for 0.  O programa deve escrever o valor da divisão 
da soma dos valores positivos pela soma dos valores
negativos que estão armazenados no vetor. Cuidado com divisões por zero.

\item Escreva uma função em  que substitui em um texto a primeira
ocorrência de  uma   palavra por   outra.  A  função  deve  retornar
\verb+true+ se a subs\-ti\-tui\-ção for bem sucedida e
\verb+false+ caso a palavra  não seja encontrada no  texto.  O texto e
as palavras são  representados  por vetores  do  tipo \verb+char+. Por
exemplo:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+
texto1  | e | x | e | m | p | r | o |   | u | n |
        +---+---+---+---+---+---+---+---+---+---+
          +---+---+---+---+---+
palavra1  | r | o |   | u | n |
          +---+---+---+---+---+
          +---+---+---+---+---+---+---+
palavra2  | l | o |   | d | o | i | s |
          +---+---+---+---+---+---+---+
        +---+---+---+---+---+---+---+---+---+---+---+---+
texto2  | e | x | e | m | p | l | o |   | d | o | i | s |
        +---+---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
\vspace{-0.2cm}
A função recebe como parâmetros o texto, a palavra a ser substituída e
a nova palavra.  No exemplo, \verb+texto1+  mostra o estado inicial do
texto  e \verb+texto2+  o   estado do texto  após  a   substituição da
\verb+palavra1+ pela \verb+palavra2+.

Você pode usar, caso seja necessário, a função:
\begin{center}
\begin{small}
\begin{verbatim}
   buscachar(texto, pos, letra);
\end{verbatim}
\end{small}
\end{center}
que busca  um  caractere (\verb+letra+) a  partir   de uma determinada
posição (\verb+pos+) em um vetor que  contém o texto (\verb+texto+). A
função \verb+buscaletra+  retorna a posição  no  vetor \verb+texto+ da
primeira ocorrência  de  \verb+letra+, se \verb+letra+  não aparece no
texto a função retorna \verb+-1+.

\item Um \emph{algoritmo genético} é um procedimento computacional de busca,
inspirado no processo biológico de  evolução, que otimiza a solução de
um  pro\-ble\-ma.  O   problema é   modelado por: uma    população de
indivíduos que representam possíveis soluções; uma função que avalia a
qualidade da solução representada por cada indivíduo da população e um
conjunto  de operadores  genéticos.   Os   indivíduos  são dados   por
sequências   de genes que   representam características  da solução do
problema.  O procedimento consiste  em aplicar os operadores genéticos
sobre a população, gerando novos indivíduos e selecionar os mais aptos
para  constituirem uma  nova população.  Esse  processo é repetido até
que uma solução adequada seja obtida.  Dentre os operadores genéticos,
o mais importante é  o de recombinação genética  (\emph{crossover}) de
dois indivíduos.  Esse operador corta  em duas partes as sequências de
genes de dois indivíduos pais (\verb+pai1+  e \verb+pai2+) e gera dois
novos   indivíduos    filhos    (\verb+filho1+    e    \verb+filho2+).
\verb+filho1+ é dado pela contatenação da primeira  parte dos genes de
\verb+pai1+  com a segunda parte  de  \verb+pai2+ e \verb+filho2+ pela
concatenação  da primeira parte de \verb+pai2+  com a segunda parte de
\verb+pai1+.  O diagrama abaixo  exemplifica a operação  em indivíduos
representados por vetores de números inteiros  onde a primeira posição
contém o tamanho do vetor:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
                          corte1
        +----+---+---+---#---+---+---+---+---+---+---+---+
pai1    | 11 | 1 | 1 | 1 # 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
        +----+---+---+---#---+---+---+---+---+---+---+---+

                                  corte2
        +----+---+---+---+---+---#---+---+---+---+---+
pai2    | 10 | 3 | 3 | 3 | 3 | 3 # 4 | 4 | 4 | 4 | 4 |
        +----+---+---+---+---+---#---+---+---+---+---+

        +----+---+---+---+---+---+---+---+---+
filho1  |  8 | 1 | 1 | 1 | 4 | 4 | 4 | 4 | 4 |
        +----+---+---+---+---+---+---+---+---+

        +----+---+---+---+---+---+---+---+---+---+---+---+---+---+
filho2  | 13 | 3 | 3 | 3 | 3 | 3 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
        +----+---+---+---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
Escreva um procedimento  em  que   execute a operação   de
recombinação descrita acima, usando  a estrutura de dados vetor.  O
procedimento deve  receber seis parâmetros, um vetor re\-pre\-sentando
o primeiro pai,   a posição  de   corte no   primeiro  pai, um   vetor
re\-pre\-sentando o segundo pai, a posição do corte  no segundo pai, e
dois vetores que receberão os novos indivíduos. No exemplo apresentado
a chamada do procedimento seria:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
   corte1 := 4;
   corte2 := 6;
   crossover(pai1, corte1, pai2, corte2, filho1, filho2);
\end{verbatim}
\end{small}
\end{center}
\vspace{-0.2cm}
Note que os vetores  devem iniciar na   posição zero e essa  posição é
usada para armazenar o tamanho do vetor. No caso do exemplo,
\verb+ pai1[0]=11+, 
\verb+ pai2[0]=10+,
\verb+filho1[0]=8 + e
\verb+ filho2[0]=13+.
Os pontos de corte devem estar dentro dos vetores:
\verb+1 < corte1 <= pai1[0] + e 
\verb+ 1 < corte2 <= pai2[0]+.

\item Escreva um procedimento em  
que implemente a subtração de números
binários. Considere que os números binários têm $N$ bits e que os bits
são armazenados em vetores de inteiros de $N$ posições indexadas de 1 a 
$N$. O primeiro bit do vetor representa o sinal do número, sendo zero (0) 
para o números positivos e um (1) para negativos. Os demais bits 
representam o valor absoluto do número. Por exemplo, para $N=11$, os 
números decimais $-13$, 12 e 1010 são representados pelos seguintes 
vetores:
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+---+
   -13: | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
        +---+---+---+---+---+---+---+---+---+---+---+

        +---+---+---+---+---+---+---+---+---+---+---+
    12: | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+

        +---+---+---+---+---+---+---+---+---+---+---+
  1010: | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
O procedimento recebe dois vetores do mesmo tamanho como parâmetros e 
deve gerar como resultado um vetor que contenha a subtração do 
primeiro pelo segundo. Por exemplo $-12 - 1010 = -1022$:
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+---+ 
  -998: | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+ 
\end{verbatim}
\end{small}
\end{center}
Caso o resultado tenha mais bits que o espaço disponível no vetor
o procedimento deve descartar os bits excedentes. 

\item Escreva um programa em  
que leia uma sequência de $N$ valores
reais não nulos ($N \leq 100$) e os insira em um vetor.
A sequência termina quando o valor lido for 0. O elemento zero não faz
parte do vetor. Leia do teclado um inteiro $p$ ($p \leq N$) e
considere que o elemento $V[p]$ como o pivô na operação
de rearranjar o vetor de tal maneira que todos os elementos à
esquerda de $V[p]$ sejam menores que ele e todos os da direta sejam
maiores ou iguais a ele. Por exemplo, considere o seguinte vetor dado
como entrada: 
\begin{center}
\begin{small}
\begin{verbatim}
    +------+------+------+------+------+------+------+
    | 99.7 | 32.6 | 2.45 | 13.4 | 26.7 | 12.2 | 0.51 | 
    +------+------+------+------+------+------+------+
\end{verbatim}
\end{small}
\end{center}
e $P$ valendo 3, o programa deve gerar como resultado um vetor onde
todos os elementos que estão à esquerda do valor $2.45$ no vetor sâo menores
que ele, enquanto que os da direita são maiores do que ele.

\item Escreva uma função em  que procura uma palavra dentro
de um texto. A função deve receber como parâmetros:
\begin{itemize}
\item um vetor do tipo \verb+texto+ que contém um texto;
\item o tamanho do vetor que contém o texto;
\item a posição inicial da busca dentro do vetor que contém o 
texto;
\item um vetor do tipo \verb+texto+ que contém uma palavra;
\item o tamanho do vetor que contém a palavra.
\end{itemize}
A função deve retornar um número inteiro indicando a posição
no texto onde a palavra foi encontrada pela primeira vez. 

Caso a palavra não seja encontrada ou algum erro ocorra o 
valor retornado deve ser zero. A busca pela palavra no texto 
deve iniciar na posição passada como parâmetro para a função.

O tipo \verb+texto+ é dado por:
\begin{center}
\begin{small}
\begin{verbatim}
   const
      TAMMAX = 10000;

   type
      texto = array [1..TAMMAX] of char;

\end{verbatim}
\end{small}
\end{center}

\item Escreva um programa em  que gere e imprima um
vetor de números reais de tamanho $N$, $1 \le N \le MAX$. A criação
do vetor deve ser feita da seguinte maneira:
\begin{itemize}
\item O tamanho $N$ do vetor deve ser lido do teclado; 
\item Os $N$ números reais são gerados aleatoriamente no
intervalo $[R_{min},R_{max}[$, com $R_{min}$ e $R_{max}$ lidos do teclado;
\item A posição em que cada elemento real é inserida no vetor também é gerada
      aleatoriamente;
\item Se uma posição $i$ sorteada já estiver ocupada, seu algoritmo deve
encontrar a primeira posição $j$ não ocupada, iniciando a partir de $i+1$ até
o final do vetor. Se todas as posição entre $i+1$ e o final do vetor
estiverem ocupadas, seu algoritmo deve pegar a primeira posição livre a
partir do início do vetor.
\end{itemize}

Dica: a função \verb|random| sem parâmetros retorna um número real no intervalo
$[0,1[$, e a função \verb|random(n)| retorna um número inteiro no intervalo
$[0,n[$.

\item Escreva um procedimento em  que remove um
  elemento de uma determinada posição $p$ de um vetor $v$ de $n$ números
  reais. O vetor não está ordenado. 
  Use a seguinte assinatura para o procedimento: 

\verb!   procedure remove(var v: vetor; var n: integer; p: integer);!


\item Escreva um procedimento em  que altere um
  vetor de $N$ números reais da seguinte forma: todos os elementos
  repetidos do vetor devem ir para o final do vetor, mas de maneira
  que estes últimos fiquem em ordem crescente. Exemplos:

\verb!   ENTRADA: 5 3 8 2 3 9 8 9 7 5 3               ENTRADA: 4 4 3 3 2 2!

\vspace*{-1mm}
\verb!   SAÍDA  : 5 3 8 2 9 7 3 3 5 8 9               SAÍDA  : 4 3 2 2 3 4!

\item Em uma festa estiveram presentes 150 pessoas. Cada uma delas recebeu
um crachá na entrada com um número entre 1 e 150, número que
representa a ordem de entrada de cada convidado.

Como em toda festa, cada um dos presentes cumprimentou outras pessoas
com apertos de mão. Ao final da festa, cada convidado sabia exatamente
quantas vezes tinha apertado a mão de outras pessoas.

Na saída, ao entregar o crachá ao recepcionista, cada convidado
informou o número do seu crachá e quantas vezes trocou apertos de mão
na festa.

Muito curioso, o recepcionista queria saber quantos convidados eram
muito populares no encontro, isto é, queria saber o número de pessoas
que apertaram a mão de pelo menos outros 120 convidados.

Faça um programa
que modele o problema do recepcionista e que produza como saída o
número de celebridades (cumprimentadas pelo menos 120 vezes) presentes
na festa.

\item Um procedimento chamado \texttt{nova\_geracao} 
recebe como parâmetros dois  vetores (origem e  destino) e o
tamanho  dos vetores.  Este  procedimento constrói  um  novo vetor  de
valores  0 ou  1  (destino) a  partir  do conteúdo  do primeiro  vetor
(origem). Seja $O$ o vetor origem e $D$ o vetor destino, a regra para 
a construção do novo vetor é dada por:
\begin{itemize}
\item 
se: $O[i-1] = 0,\ O[i] = 0,\ O[i+1] = 0$ então: $D[i] = 0$
\item 
se: $O[i-1] = 0,\ O[i] = 0,\ O[i+1] = 1$ então: $D[i] = 1$
\item 
se: $O[i-1] = 0,\ O[i] = 1,\ O[i+1] = 0$ então: $D[i] = 1$
\item 
se: $O[i-1] = 0,\ O[i] = 1,\ O[i+1] = 1$ então: $D[i] = 1$
\item 
se: $O[i-1] = 1,\ O[i] = 0,\ O[i+1] = 0$ então: $D[i] = 1$
\item 
se: $O[i-1] = 1,\ O[i] = 0,\ O[i+1] = 1$ então: $D[i] = 0$
\item 
se: $O[i-1] = 1,\ O[i] = 1,\ O[i+1] = 0$ então: $D[i] = 0$
\item 
se: $O[i-1] = 1,\ O[i] = 1,\ O[i+1] = 1$ então: $D[i] = 0$
\end{itemize}
Onde $i$ indica uma posição do vetor $D$. Considere o valor 0 para as
bordas externas do vetor origem $O$. Escreva o procedimento
\texttt{nova\_geracao} e separe a regra descrita acima em uma função
que dados os valores das 3 posições consecutivas do vetor origem
($O[i-1], O[i], O[i+1]$) calcula o valor correspondente no vetor
destino ($D[i]$).

\item Faça um programa em  que simule o 
tráfego em um trecho de uma rodovia de mão única, ou seja, uma rodovia na 
qual os veículos entram de um lado e saem do outro. 

\begin{itemize}
    \item A rodovia é representada por um vetor com \verb|TAM_RODOVIA| posições;
    \item A simulação ocorre durante \verb|MAX_TEMPO| iterações;
    \item Através da chamada do procedimento \\
          \verb|detecta_entrada(VAR tipo, placa, velocidade:INTEGER)|,\\
          o programador é 
          informado sobre a ocorrência ou não da entrada de um veículo na
          rodovia, bem como o tipo do veículo, sua placa e sua respectiva 
          velocidade, onde:
        \begin{itemize}
            \item \emph{tipo:} $0$ - nenhuma nova entrada, 
                               $1$ - entrou automóvel, 
                               $2$ - entrou caminhão;
            \item \emph{placa:} um número inteiro;
            \item \emph{velocidade:} a velocidade de deslocamento do veículo 
                   (em posições/unidade de tempo).
        \end{itemize}
    \item Veículos do tipo automóvel ocupam uma posição da rodovia. 
          Caminhões ocupam duas posições.
    \item Quando veículos mais rápidos alcançam veículos mais lentos, os 
          primeiros devem andar mais devagar, pois não podem ultrapassar.
\end{itemize}    
    

A cada unidade de tempo em que algum veículo sair da rodovia, seu programa
deve imprimir esta unidade de tempo e o número da placa do veículo que saiu.

Exemplo: (\verb|TAM_RODOVIA=7|, \verb|MAX_TEMPO=10|)
\begin{itemize}
    \item Entrada:
    \begin{itemize}
        \item \textbf{t=1:} $tipo=2, placa=35, velocidade=1$
        \item \textbf{t=2:} $tipo=0$
        \item \textbf{t=3:} $tipo=1, placa=27, velocidade=4$
        \item \textbf{t=4:} $tipo=0$
        \item \textbf{t=5:} $tipo=0$
        \item \textbf{t=6:} $tipo=1, placa=16, velocidade=2$
        \item \textbf{t=7:} $tipo=0$
        \item \textbf{t=8:} $tipo=0$
        \item \textbf{t=9:} $tipo=0$
        \item \textbf{t=10:} $tipo=0$
    \end{itemize}

    \item Representação gráfica:

    \begin{itemize}
        \item \textbf{t=1:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $35_1$&$35_1$& & & & &\\ \hline \end{tabular}
        \item \textbf{t=2:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline &$35_1$& $35_1$& & & &\\ \hline \end{tabular}
        \item \textbf{t=3:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $27_4$& & $35_1$&$35_1$ & & &\\ \hline \end{tabular}
        \item \textbf{t=4:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & $27_4$& $35_1$& $35_1$& &\\ \hline \end{tabular}
        \item \textbf{t=5:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & $27_4$& $35_1$& $35_1$&\\ \hline \end{tabular} 
        \item \textbf{t=6:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $16_2$& & & & $27_4$& $35_1$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=7:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & &$16_2$ & & & $27_4$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=8:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & $16_2$& & $27_4$ \\ \hline \end{tabular}
        \item \textbf{t=9:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & & $16_2$ \\ \hline \end{tabular}
        \item \textbf{t=10:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & & \\ \hline \end{tabular}
    \end{itemize}

    \item Saída:
    \begin{itemize}
        \item \textbf{t=8:} $35$
        \item \textbf{t=9:} $27$
        \item \textbf{t=10:} $16$
    \end{itemize}
\end{itemize}

%\begin{lstlistings}[frame=trBL]
%Code
%\end{lstlistings}


\item Você deve incluir no enunciado da questão anterior a
existência de uma pista de ultrapassagem. Agora, veículos mais rápidos 
podem mover-se para a pista de ultrapassagem ao alcançarem veículos mais 
lentos, desde que não haja ninguém ocupando aquele trecho de pista. 
Eles devem retornar à pista original assim que tiverem completado 
a ultrapassagem, retomando a velocidade original. Você deve escrever unicamente
os procedimentos modificados ou novos que levam em conta este novo fato.

Exemplo da nova saída para a entrada original:
\begin{itemize}
    \item Representação gráfica:
    \begin{itemize}
        \item \textbf{t=1:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\
            \hline $35_1$&$35_1$& & & & &\\ \hline \end{tabular}
        \item \textbf{t=2:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline &$35_1$& $35_1$& & & &\\ \hline \end{tabular}
        \item \textbf{t=3:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline $27_4$& & $35_1$&$35_1$ & & &\\ \hline \end{tabular}
        \item \textbf{t=4:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & $27_4$& & &\\ 
            \hline & & & $35_1$& $35_1$& &\\ \hline \end{tabular}
        \item \textbf{t=5:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & $35_1$& $35_1$&$27_4$\\ \hline \end{tabular} 
        \item \textbf{t=6:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline $16_2$& & & & & $35_1$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=7:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & &$16_2$ & & & & $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=8:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & $16_2$& &  \\ \hline \end{tabular}
        \item \textbf{t=9:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & & & $16_2$ \\ \hline \end{tabular}
        \item \textbf{t=10:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & & & \\ \hline \end{tabular}
    \end{itemize}
    \item Saída:
    \begin{itemize}
        \item \textbf{t=6:} $27$
        \item \textbf{t=8:} $35$
        \item \textbf{t=10:} $16$
    \end{itemize}
\end{itemize}


\item Mateus, um engenheiro novato, está desenvolvendo uma notação posicional original
para representação de números inteiros. Ele chamou esta notação de UMC 
(Um método curioso). A notação UMC usa os mesmos dígitos da notação decimal,
isto é, de 0 a 9.
%
Para converter um número $A$ da notação UMC para a notação decimal deve-se
adicionar $K$ termos, onde $K$ é o número de dígitos de $A$ (na notação UMC).
O valor do $i$-ésimo termo correspondente ao $i$-ésimo dígito $a_i$, contando
da direita para a esquerda é $a_i \times i!$. 

Por exemplo, 719$_{UMC}$ é equivalente a 53$_{10}$, pois
$7 \times 3! + 1 \times 2! + 9 \times 1! = 53$.

Mateus está começando seus estudos em teoria dos números e 
provavelmente não sabe quais as propriedades que um sistema de numeração
deve ter, mas neste momento ele está interessado em converter
os números da notação UCM para a notação decimal. Você pode ajudá-lo?

\noindent
\textbf{Entrada}:
cada caso de teste é fornecido em uma linha simples que contém um 
número não vazio de no máximo 5 dígitos, representando um número 
em notação UMC. Este número não contém zeros a esquerda. O último
teste é sequido por uma linha contendo um zero.

\noindent
\textbf{Saída}:
para cada caso de teste imprimir uma linha simples contendo a representação
em notação decimal do correspondente número em UMC seguido do cálculo feito
para a conversão.

\noindent
\textbf{O programa}:
seu programa deve, para cada número da entrada, convertê-lo em um vetor
de inteiros, sendo que cada dígito do número é um elemento do vetor,
e fazer os cálculos usando este vetor. 

\noindent
Exemplos de entrada e saída:
\begin{verbatim}
ENTRADA                SAÍDA
719                    53 = 7 x 3! + 1 x 2! + 9 x 1!
1                      1 = 1 x 1!
15                     7 = 1 x 2! + 5 x 1!
110                    8 = 1 x 3! + 1 x 2! + 0 x 1!
102                    8 = 1 x 3! + 0 x 2! + 2 x 1!
0 
\end{verbatim}


\item Sabemos que nos compiladores  mais recentes, nos
  quais existe o tipo \textsf{string}, podemos realizar de maneira simples
   operações com  palavras.  Imagine, no entanto, que  estamos usando um
  compilador  \emph{Pascal}  no  qual  não  existe  este  tipo.  Neste  caso  o
  programador deve  implementar por  sua própria conta  os procedimentos
  com palavras. Neste exercício iremos considerar a seguinte 
  declaração alternativa para o tipo \textsf{string}: \\
\begin{center}
\verb+type palavra = array[1..MaxTam] of char;+ 
\end{center}
  Implemente uma função em \emph{Pascal} que receba
  como parâmetros duas variáveis do tipo \textsf{MeuString} e retorne -1 se a
  primeira palavra for lexicograficamente menor que a segunda, 0 se
  forem iguais, e +1 no caso que resta.



\item Faça um programa que leia um certo número indefinido de
vetores e que imprima o vetor original (O) e um vetor gerado (G)
após um processo de compactação
que consiste na eliminação de todos os elementos repetidos
em cada vetor. Considere que a entrada de dados é feita em
um vetor por linha, sendo que o primeiro elemento da linha é
o tamanho de cada vetor e os elementos restantes da linha são
os elementos do vetor. Quando o tamanho for zero significa que 
terminou a entrada de dados. Por exemplo, considere a seguinte
entrada:

\begin{verbatim}
5 2 4 7 -1 2
3 1 1 1 
7 3 4 5 3 4 5 1
0
\end{verbatim}

Deverá produzir como saída o seguinte:

\begin{verbatim}
O: 2 4 7 -1 2
G: 2 4 7 -1
O: 1 1 1
G: 1
O: 3 4 5 3 4 5 1
G: 3 4 5 1
\end{verbatim}

\item Considere uma sequência de dígitos binários como:

011100011

Uma maneira de criptografar essa sequência de bits é adicionar
à cada dígito a soma dos seus dígitos adjacentes. Por exemplo,
a sequência acima se tornaria:

123210122

Se $P$ é a sequência original e $Q$ é a sequência criptografada,
então $Q[i] = P[i-1] + P[i] + P[i+1]$ para todas as posições $i$
da sequência. Considerando uma sequência de tamanho $n$ e seus
índices variando de $0$ a $n-1$, os dígitos $P[-1]$ e $P[n]$ não
fazem parte da sequência original e são tratados como zeros na
operação de codificação.

Assumindo $P[0] = 0$ temos:
\begin{itemize}
\item
$Q[0] = P[0] + P[1] = 0 + P[1] = 1$, logo $P[1] = 1$.
\item
$Q[1] = P[0] + P[1] + P[2] = 0 + 1 + P[2] = 2$, logo $P[2] = 1$.
\item
$Q[2] = P[1] + P[2] + P[3] = 1 + 1 + P[3] = 3$, logo $P[3] = 1$.
\item
Repetindo a operação temos: $P[4] = 0$, $P[5] = 0$, $P[6] = 0$, $P[7] = 1$ e $P[8] = 1$.
\end{itemize}

Agora repetindo o mesmo processo para $P[0] = 1$ temos:
\begin{itemize}
\item
$Q[0] = P[0] + P[1] = 1 + P[1] = 1$, logo $P[1] = 0$.
\item
$Q[1] = P[0] + P[1] + P[2] = 1 + 0 + P[2] = 2$, logo $P[2] = 1$.
\item
$Q[2] = P[1] + P[2] + P[3] = 0 + 1 + P[3] = 3$, o que nos leva a conclusão que $P[3] = 2$.
Entretanto isso viola o fato da sequência original ser binária. Portanto não
existe uma decodificação possível considerando o primeiro dígito da sequência original
valendo $1$.
\end{itemize}
Note que este algoritmo pode gerar ou decodificar uma sequência criptografada em até duas 
possíveis sequências originais, uma iniciando com 0 e outra iniciando com 1.

Escreva um procedimento em  que receba como parâmetros um vetor de
números inteiros contendo a sequência criptografada e a decodifica em dois outros
vetores de números inteiros. Caso uma das decodificações não seja possível, como
no caso do exemplo para $P[0] = 1$, o vetor correspondente deve ser preenchido com -1
na posição inicial.

Outros exemplos:
\begin{itemize}
\item
$123210122 = 011100011, -1$
\item
$11 = 01, 10$
\item
$22111 = -1, 11001$
\item
$123210120 = -1, -1$
\item
$3 = -1, -1$
\item
$12221112222221112221111111112221111 = \\
01101001101101001101001001001101001, \\
10110010110110010110010010010110010$
\end{itemize}

\item Escrever um programa para ler um texto e imprimir uma distribuição de
   frequências para  palavras do texto  (quantas palavras de  uma letra,
   quantas de duas letras, etc.).


\item Escreva um programa em \emph{Pascal} que leia do teclado o gabarito de uma prova
de 20 questões de múltipla escolha, onde as respostas são inteiros de 1 a
5.  Em seguida, o programa deve ler o número de alunos que prestaram a prova
e, para cada aluno, a sua matrícula (um inteiro) e as respectivas respostas.
O programa deve calcular e escrever:
\begin{itemize}
\item a relação de alunos ordenados pela nota, supondo que cada questão vale 5 pontos;
\item para cada questão: quantos alunos acertaram a questão
\end{itemize}




\end{enumerate}
\item Faça  um programa que leia e  armazene em um vetor  uma sequência de
inteiros.  Em seguida  o programa  deve  ler uma  sequência de  inteiros
informados pelo usuário e, para cada  um deles, dizer se ele pertence ou
não ao vetor armazenado previamente. 

\item Faça um  programa que  leia duas  sequências de  $n$ inteiros  em dois
vetores distintos,  digamos, $v$ e  $w$ e verifique  se os dois  vetores são
idênticos. 

\item Faça um programa em  que leia dois vetores de números reais
e descubra se um deles é permutação do outro, isto é, se eles
tem os mesmos elementos, ainda que em ordem diferente.
A quantidade de elementos lidos em cada vetor é no  máximo 100,  e
cada sequência termina quando o valor 0 é digitado. 
Por   exemplo: 

        $[2,2,0,3,4]$   e  $[2,2,0,3,4]$:   sim.
  
        $[2,2,0,3,4]$ e  $[4,3,2,0,2]$: sim.
        
        $[2,2,0,3,4]$ e $[4,3,4,0,2]$: não. 
        
        $[3,0,5]$ e $[3,0,5,3]$: não.

Implemente três
versões deste problema:
\begin{itemize}
\item ordenando os vetores para em seguida compará-los;
\item sem ordenar os vetores;
\item crie uma
 função que  retorna  0 se $x$  não  pertence a  $v$ e  caso contrário
 retorna o índice  do vetor onde  $x$  se encontra. Use esta função para 
 resolver este problema. 
\end{itemize}




\item Faça  um  programa  que   leia  duas  sequências  de  inteiros,  não
necessariamente  contendo a  mesma quantidade  de números. Seu programa
deverá:
\begin{itemize} 
\item dizer  se a segunda sequência está contida na primeira. Exemplo:
\begin{verbatim}
v1: 7 3 2 3 2 6 4 7 
v2: 3 2 6
Saída: sim
\end{verbatim}
\item construir um terceiro  vetor, sem  destruir os  originais, que é  
      a concatenação  do primeiro com o segundo;
\begin{verbatim}
v1: 7 3 2 6
v2: 5 1 8 4 9
Saída: 1 2 3 4 5 6 7 8 9
\end{verbatim}
\item ordená-los, e em seguida imprimir todos os números ordenados 
      em ordem crescente. Exemplo:
\begin{verbatim}
v1: 7 3 2 6
v2: 5 1 8 4 9
Saída: 1 2 3 4 5 6 7 8 9
\end{verbatim}
\end{itemize}

\item Crie uma função que receba um vetor de inteiros de 
     tamanho $n$ e devolva o valor \emph{true} se o vetor estiver ordenado e 
     \emph{false} em caso contrário.

\item Aproveitando as soluções dos problemas anteriores, escreva um programa
     que leia dois vetores de inteiros $v$ e $w$, 
     de dimensões $m$ e $n$ 
     respectivamente, verifique se eles estão ordenados, ordene-os em caso 
     contrário e, em seguida, imprima a intercalação dos dois. \\
     Exemplo de intercalação: $v$: 1 4 6 9; $w$: 2, 3, 5, 7. \\
     Saída: 1, 2, 3, 4, 5, 6, 7, 9. 

\item Dados dois números naturais $m$ e $n$, uma frase com $m$ letras
e uma palavra com $n$ letras, escreva um procedimento que determine o número de
vezes que a palavra ocorre na frase e a posição em que cada ocorrência inicia.

    Exemplo:
    \begin{verbatim}
    Para M = 30, N = 3, a palavra ANA e a frase:
        ANA E MARIANA GOSTAM DE BANANA
    A palavra ANA ocorre 4 vezes, nas posições 1, 11, 26, 28.
    \end{verbatim}

\item Dada uma sequência de $N$ números, determinar quantos números dintintos
compõe  a sequência e  o número  de vezes  que cada  um deles  ocorre na
mesma. Exemplo:

N=5
1 2 3 2 3 
a sequência tem três números distintos, 1, 2 e 3. Ocorrências:
1 ocorre 1 vez
2 ocorre 2 vezes
3 ocorre 2 vezes

\item Dadas  duas  sequências  com  $n$  números  inteiros  entre  0  e  1,
interpretados como números binários:
\begin{enumerate}
     \item imprimir o valor decimal dos números;
     \item calcular a soma de ambos (em binário), usando o ``vai-um'';
     \item imprimir o valor decimal da soma.
\end{enumerate}


\item Escreva um programa em  que leia os seguintes valores:
um inteiro $B$, um inteiro $N$ ($1 \leq N \leq 10$), e $N$ valores inteiros.
A ideia é que estes valores sejam entendidos como a representação
de um número não negativo na base $B$. 
Estes valores deverão ser inseridos em um vetor de tamanho $N+1$, onde
a primeira posição armazena a base $B$ e as outras $N$ posições
o restante dos números lidos. 
%
Note que o  intervalo de valores possíveis para cada dígito na
base $B$ é $[0, B-1]$.
%
Seu programa deve retornar o valor em decimal do número representado
no vetor. Se o número representado no vetor não for válido na
base $B$ então deverá ser retornado o código de erro ``-1''.
Por exemplo, se $B=3$ o número 2102 na base 3 equivale ao valor decimal 65;
se $B=4$ o número $35$ é inválido na base 4.


\item Faça um programa que, 
dadas duas sequências com
$N$ números inteiros entre 0 e 9, interpretadas como dois números
inteiros de $N$ algarismos, calcular a sequência de números que
representa a soma dos dois inteiros, usando o ``vai-um''. Por exemplo:\\

\verb|        N=6,|\\
\verb|                4 3 4 2 5 1|\\
\verb|              + 7 5 2 3 3 7|\\
\verb|              1 1 8 6 5 8 8|



\item Dada  uma  sequência  $x_1$,  $x_2$, \ldots,  $x_n$  de  
números  inteiros,
determinar um segmento de soma  máxima.  Exemplo: na sequência 5, 2, -2,
-7, 3, 14,  10, -3, 9, -6, 4,  1, a soma do maior segmento  é 33, obtida
pela soma dos números de 3 até 9. 
 
\item Implemente um programa que leia um vetor de 1 milhão de inteiros
   em um vetor de inteiros. Gere um número aleatório e o procure
   neste vetor de duas maneiras diferentes: uma usando busca com 
   sentinela e outra usando busca binária. Seu programa deve imprimir
   uma tabela com o número de comparações feitas em cada um dos casos
   acima (busca com sentinela e busca binária). Desconsidere o tempo
   gasto com ordenação no caso da busca binária. A busca com sentinela
   deve ser feita em um vetor não ordenado. Gere 200 números aleatórios
   e imprima a média de comparações para cada um dos dois algoritmos
   sendo testados.

\item 
Suponha que um ex\'ercito tenha 20 regimentos e que eles est\~ao em processo
de forma\c c\~ao. Inicialmente o primeiro tem 1000 homens, o segundo 950,
o terceiro 900, e assim por diante, at\'e o vig\'esimo que tem 50. Suponhamos
que a cada semana 100 homens s\~ao enviados para cada regimento, e no final
da semana o maior regimento \'e enviado para o {\em front}. Imaginemos que o
general do quinto regimento \'e companheiro de xadrez do comandante supremo,
e que eles est\~ao no meio de uma partida. O comandante supremo ent\~ao
envia apenas 30 homens para o quinto regimento a cada semana, esperando com
isto poder acabar o jogo com seu colega.
Escreva um programa em 
que diga, a cada semana, qual \'e o regimento enviado ao {\em front} e mostre o {\em status} dos outros regimentos. O programa
deve tamb\'em determinar exatamente quantas semanas levar\'a o quinto regimento
para ser deslocado ao {\em front}. 

\item Suponha que voc\^e esteja usando o m\'etodo da ordenação 
por sele\c c\~ao. Qual das sequências abaixo requerir\'a o menor n\'umero
de trocas? Quantas? Qual requerir\'a o maior n\'umero de trocas? Quantas?
Explique.
\begin {enumerate}
\item 10, 9, 8, 7, 6, 5, 4, 3, 2, 1.
\item 5, 4, 3, 2, 1, 10, 9, 8, 7, 6.
\item 10, 1, 9, 2, 8, 3, 7, 4, 6, 5.
\item 2, 3, 4, 5, 6, 7, 8, 9, 10, 1.
\item 1, 10, 2, 9, 3, 8, 4, 7, 5, 6.
\end {enumerate}

\item Suponha que voc\^e tem uma vari\'avel do tipo vetor declarada como:
\emph{array [1..50] of real;}. 
Fa\c ca uma fun\c c\~ao 
que inicialize o vetor de modo que os elementos
de \'{\i}ndices \'{\i}mpares recebam o valor inicial -2.0 e os elementos
de \'{\i}ndices pares recebam o valor inicial 7.0. Sua função deve
fazer uso de um único comando de repetição, que incrementa de um em um, e de 
nenhum comando de desvio condicional.

\item Qual dos seguintes problemas requer o uso de vetores para uma solu\c c\~ao elegante?
\begin {enumerate}
\item Ler cerca de duzentos n\'umeros e imprimir os que est\~ao em uma certa faixa;
\item Computar a soma de uma sequ\^encia de n\'umeros;
\item Ler exatamente duzentos n\'umeros e orden\'a-los em ordem crescente;
\item Encontrar o segundo menor elemento de uma sequ\^encia de entrada;
\item Encontrar o menor inteiro de uma sequ\^encia de inteiros.
\end {enumerate}

\item Considere um vetor  declarado como: 
\emph{array [1..50] of integer} que tem a 
particularidade de todos os elementos estarem entre 1 e 30, sendo que
nenhum \'e repetido. Fa\c ca um programa
que ordene o vetor de maneira eficiente explorando esta característica e fazendo
o menor n\'umero poss\'{\i}vel de trocas.

\item   Dada uma sequência $x_1, x_2, \ldots, x_k$ de números
  reais, verifique  se existem dois segmentos  consecutivos iguais nesta
  sequência, isto é, se existem $i$ e $m$ tais que:
\[ x_i, x_{i+1}, \ldots, x_{i+m-1}=x_{i+m}, x_{i+m+1}, \ldots, x_{i+2m-1}.
\]
Imprima, caso existam,  os valores de $i$ e de  $m$. Caso contrário, não
imprima  nada. Exemplo:  Na sequência  7,9,5,4,5,4,8,6, existem  $i=3$ e
$m=2$. 

\item   Um coeficiente binomial, geralmente denotado
  $\binom{n}{k}$, representa o número de possíveis combinações de $n$
  elementos tomados $k$ a $k$. Um ``Triângulo de Pascal'', uma homenagem
  ao grande matemático Blaise Pascal, é uma tabela de valores de
  coeficientes combinatoriais para pequenos valores de $n$ e $k$. Os
  números que não são mostrados na tabela têm valor zero. Este triângulo
  pode ser construído automaticamente usando-se uma propriedade
  conhecida dos coeficientes binomiais, denominada ``fórmula da
  adição'':
$\binom{r}{k} = \binom{r-1}{k} + \binom{r-1}{k-1}.$
Ou seja, cada elemento do triângulo é a soma de dois elementos da linha
anterior, um da mesma coluna e um da coluna anterior. 
Veja  um  exemplo de  um  triângulo  de Pascal  com  7  linhas:
\[\begin{array}{ccccccc}
1 \\
1 & 1 \\
1 & 2 & 1 \\
1 & 3 & 3 & 1 \\
1 & 4 & 6 & 4 & 1 \\
1 & 5 & 10 & 10 & 5 & 1 \\
1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{array}
\]
Faça um programa que imprima na tela um triângulo de Pascal
com 10 linhas.  Seu programa deve obrigatoriamente fazer uso de
exatamente dois vetores durante o processo de construção. Um deles
conterá a última linha ímpar gerada, enquanto que o outro conterá a
última linha par gerada. Lembre-se que os elementos que não aparecem na
tabela tem valor nulo. Você deve sempre ter o controle do tamanho da
última linha impressa (o tamanho útil dos vetores em cada passo). Você
deve também usar um procedimento para imprimir o vetor. Observe que não
há entrada de dados, os dois vetores são gerados, um a partir do outro.
O único elemento da primeira linha tem o valor 1. Você deve
obrigatoriamente declarar um tipo vetor com tamanho máximo
Tam\_max\_vetor, e o seu programa deverá tomar cuidado para manipular
corretamente vetores de tamanho menor do que o tamanho máximo, impedindo
que haja uma atribuição em posição ilegal de memória. 


\item Resolva o problema do triângulo de Pascal usando somente um vetor.

\item Seja um polinômio $p(x)= a_0 + a_1 x + a_2 x^2 + \ldots + a_n x^n$ de
  grau $n \ge 2$. Uma possível maneira de calcular uma raiz do polinômio
  é pelo ``método de Newton''. Este método consiste em se fornecer uma
  aproximação inicial para a raiz, isto é, um valor que não é a raiz
  exata, mas é um valor próximo.  Assim, se $x_0$ é esta
  aproximação inicial, $p(x_0)$ não é zero mas espera-se que
  seja próximo de zero.  A obtenção da raiz pelo método de Newton é
  feita pelo refinamento desta solução inicial, isto é, pela tentativa
  de minimizar o erro cometido. Isto é feito pela expressão seguinte:
\[x_{n+1}=x_{n}-\frac{p(x_{n})}{p\prime(x_{n})},\]  $n=0,1,2,\ldots$,  e
  onde $p\prime(x)$ é a primeira derivada de $p(x$). Usualmente, repete-se
  este refinamento até que $|x_{n+1}-x_{n}| < \epsilon, \epsilon>0$, ou
  até que $m$ iterações tenham sido executadas. \\
  Construa um programa em  que receba como dados de entrada 
  um polinômio $p(x)= a_0 + a_1 x + a_2 x^2 + \ldots + a_n x^n$ e
  uma  aproximação inicial  $x_0$ da  raiz de  $p(x)$, $\epsilon>0$  e o
  número  máximo de  iterações, e  calcule  uma aproximação  da raiz  de
  $p(x)$ pelo método de Newton. Utilize obrigatoriamente um procedimento
  que receba como parâmetro  um polinômio $p(x)$ (incluindo a informação
  sobre o grau do polinômio) e que calcule e retorne a função
  derivada  $p\prime(x)$.  Utilize também  uma  função  que receba  como
  parâmetros um polinômio $p(x)$ e um valor real $\overline{x}$ e retorne
  o   valor    do   polinômio    no   ponto   $\overline{x}$,    isto   é
  $p(\overline{x})$. Use  esta função para  calcular, a cada  iteração do
  método    de    Newton,    os    valores   de    $p(x_{n})$    e    de
  $p\prime(x_{n})$.  

\item Faça um programa em  que leia uma sequência de 10 
     letras (caracteres de A a Z), as armazene em um vetor de 10 posições 
     e imprima a lista de letras repetidas no vetor. Sendo assim, para os 
     dados: A J G A D F G A A, a saída deve ser: A G.

\item Escreva o programa da busca binária de um valor $x$ num 
     vetor de inteiros que, ao invés de achar a primeira ocorrência do valor 
     na lista, identifique e imprima o menor índice do vetor no qual o valor 
     ocorra.

\item Escreva um programa que leia uma sequência de {\em código de
operação} e {\em valor}, onde o {\em código de operação} é um inteiro com
os seguintes valores:
\begin{itemize}
\item 0 (zero): fim
\item 1 (um): inserção
\item 2 (dois): remoção
\end{itemize} 

O {\em valor} lido é um real que deve ser inserido em um vetor (caso a
operação seja 1), ou removido do vetor (caso a operação seja 2).   As
inserções no vetor devem ser realizadas de forma que o vetor esteja sempre
ordenado.   No final do programa o vetor resultante deve ser impresso.

Detalhamento:
\begin{itemize}
\item a quantidade máxima de valores que pode  ser inserida é 100;
\item se a quantidade máxima for ultrapassada o programa deve dar uma
mensagem de erro;
\item se for requisitada a remoção de um número não existente o programa
  deve dar uma mensagem de erro;
\item se o código de operação for inválido o programa deve continuar lendo
um novo código até que ele seja 0 (zero), 1 (um) ou 2 (dois).
\end{itemize}

\noindent
{\bf Exemplo de execução: }
\begin{small}
\begin{verbatim}
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 45.3 
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 34.3 
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 40.8
Entre com operacao (0=fim, 1=insercao, 2=remocao): 2 
Valor: 34.3
Entre com operacao (0=fim, 1=insercao, 2=remocao): 0
Vetor resultante
40.8   45.3 
\end{verbatim}
\end{small}

\begin{center}
\begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|l}
\multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \\ \cline{1-6} 
&&&&&& \mbox{início}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
45.3&&&&&& \mbox{após inserção de 45.3}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
34.3&45.3&&&&& \mbox{após inserção de 34.3}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
34.3&40.8&45.3&&&& \mbox{após inserção de 40.8}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
40.8&45.3&&&&& \mbox{após remoção de 34.3}\\ \cline{1-6}
\end{tabular}
\end{center}

\item Escreva um programa 
que leia duas sequências de caracteres e
verifica se a segunda sequência é subpalavra da primeira.
Por exemplo, {\em todo} é subpalavra de {\em metodo} e
{\em ar} é subpalavra de {\em farmacia}.  Porém, {\em todo} não é
subpalavra de {\em todavia}.   A leitura das sequências deve ser feita
caracter por caracter e o final de cada sequência é sinalizada pelo
caracter '.'.    Se a segunda sequência é uma subpalavra, a saída do 
programa deve ser a posição na qual ela começa.  Caso contrário, escrever
a mensagem ``Nao eh subpalavra.''. 
{Observações:} 
\begin{itemize}
\item cada sequência tem no máximo 80 caracteres.
\item você não pode utilizar funções de manipulação de cadeias de
caracteres existentes no compilador, mas somente as funções para o
tipo {\tt char}.
\end{itemize}

\noindent
{Exemplo de execução: }
\small
\begin{verbatim}
Entre com duas palavras terminadas por ponto:
metodo.todo.

A segunda subpalavra comeca na posicao 3 da primeira.
\end{verbatim}



\item Escreva um programa que leia uma sequência de $n$ valores
reais ($n \leq 100$) e os insira num vetor.  A sequência termina quando o
valor lido for 0.  O programa deve escrever o valor da divisão 
da soma dos valores positivos pela soma dos valores
negativos que estão armazenados no vetor. Cuidado com divisões por zero.

\item Escreva uma função em  que substitui em um texto a primeira
ocorrência de  uma   palavra por   outra.  A  função  deve  retornar
\verb+true+ se a subs\-ti\-tui\-ção for bem sucedida e
\verb+false+ caso a palavra  não seja encontrada no  texto.  O texto e
as palavras são  representados  por vetores  do  tipo \verb+char+. Por
exemplo:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+
texto1  | e | x | e | m | p | r | o |   | u | n |
        +---+---+---+---+---+---+---+---+---+---+
          +---+---+---+---+---+
palavra1  | r | o |   | u | n |
          +---+---+---+---+---+
          +---+---+---+---+---+---+---+
palavra2  | l | o |   | d | o | i | s |
          +---+---+---+---+---+---+---+
        +---+---+---+---+---+---+---+---+---+---+---+---+
texto2  | e | x | e | m | p | l | o |   | d | o | i | s |
        +---+---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
\vspace{-0.2cm}
A função recebe como parâmetros o texto, a palavra a ser substituída e
a nova palavra.  No exemplo, \verb+texto1+  mostra o estado inicial do
texto  e \verb+texto2+  o   estado do texto  após  a   substituição da
\verb+palavra1+ pela \verb+palavra2+.

Você pode usar, caso seja necessário, a função:
\begin{center}
\begin{small}
\begin{verbatim}
   buscachar(texto, pos, letra);
\end{verbatim}
\end{small}
\end{center}
que busca  um  caractere (\verb+letra+) a  partir   de uma determinada
posição (\verb+pos+) em um vetor que  contém o texto (\verb+texto+). A
função \verb+buscaletra+  retorna a posição  no  vetor \verb+texto+ da
primeira ocorrência  de  \verb+letra+, se \verb+letra+  não aparece no
texto a função retorna \verb+-1+.

\item Um \emph{algoritmo genético} é um procedimento computacional de busca,
inspirado no processo biológico de  evolução, que otimiza a solução de
um  pro\-ble\-ma.  O   problema é   modelado por: uma    população de
indivíduos que representam possíveis soluções; uma função que avalia a
qualidade da solução representada por cada indivíduo da população e um
conjunto  de operadores  genéticos.   Os   indivíduos  são dados   por
sequências   de genes que   representam características  da solução do
problema.  O procedimento consiste  em aplicar os operadores genéticos
sobre a população, gerando novos indivíduos e selecionar os mais aptos
para  constituirem uma  nova população.  Esse  processo é repetido até
que uma solução adequada seja obtida.  Dentre os operadores genéticos,
o mais importante é  o de recombinação genética  (\emph{crossover}) de
dois indivíduos.  Esse operador corta  em duas partes as sequências de
genes de dois indivíduos pais (\verb+pai1+  e \verb+pai2+) e gera dois
novos   indivíduos    filhos    (\verb+filho1+    e    \verb+filho2+).
\verb+filho1+ é dado pela contatenação da primeira  parte dos genes de
\verb+pai1+  com a segunda parte  de  \verb+pai2+ e \verb+filho2+ pela
concatenação  da primeira parte de \verb+pai2+  com a segunda parte de
\verb+pai1+.  O diagrama abaixo  exemplifica a operação  em indivíduos
representados por vetores de números inteiros  onde a primeira posição
contém o tamanho do vetor:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
                          corte1
        +----+---+---+---#---+---+---+---+---+---+---+---+
pai1    | 11 | 1 | 1 | 1 # 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
        +----+---+---+---#---+---+---+---+---+---+---+---+

                                  corte2
        +----+---+---+---+---+---#---+---+---+---+---+
pai2    | 10 | 3 | 3 | 3 | 3 | 3 # 4 | 4 | 4 | 4 | 4 |
        +----+---+---+---+---+---#---+---+---+---+---+

        +----+---+---+---+---+---+---+---+---+
filho1  |  8 | 1 | 1 | 1 | 4 | 4 | 4 | 4 | 4 |
        +----+---+---+---+---+---+---+---+---+

        +----+---+---+---+---+---+---+---+---+---+---+---+---+---+
filho2  | 13 | 3 | 3 | 3 | 3 | 3 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
        +----+---+---+---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
Escreva um procedimento  em  que   execute a operação   de
recombinação descrita acima, usando  a estrutura de dados vetor.  O
procedimento deve  receber seis parâmetros, um vetor re\-pre\-sentando
o primeiro pai,   a posição  de   corte no   primeiro  pai, um   vetor
re\-pre\-sentando o segundo pai, a posição do corte  no segundo pai, e
dois vetores que receberão os novos indivíduos. No exemplo apresentado
a chamada do procedimento seria:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
   corte1 := 4;
   corte2 := 6;
   crossover(pai1, corte1, pai2, corte2, filho1, filho2);
\end{verbatim}
\end{small}
\end{center}
\vspace{-0.2cm}
Note que os vetores  devem iniciar na   posição zero e essa  posição é
usada para armazenar o tamanho do vetor. No caso do exemplo,
\verb+ pai1[0]=11+, 
\verb+ pai2[0]=10+,
\verb+filho1[0]=8 + e
\verb+ filho2[0]=13+.
Os pontos de corte devem estar dentro dos vetores:
\verb+1 < corte1 <= pai1[0] + e 
\verb+ 1 < corte2 <= pai2[0]+.

\item Escreva um procedimento em  
que implemente a subtração de números
binários. Considere que os números binários têm $N$ bits e que os bits
são armazenados em vetores de inteiros de $N$ posições indexadas de 1 a 
$N$. O primeiro bit do vetor representa o sinal do número, sendo zero (0) 
para o números positivos e um (1) para negativos. Os demais bits 
representam o valor absoluto do número. Por exemplo, para $N=11$, os 
números decimais $-13$, 12 e 1010 são representados pelos seguintes 
vetores:
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+---+
   -13: | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
        +---+---+---+---+---+---+---+---+---+---+---+

        +---+---+---+---+---+---+---+---+---+---+---+
    12: | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+

        +---+---+---+---+---+---+---+---+---+---+---+
  1010: | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
O procedimento recebe dois vetores do mesmo tamanho como parâmetros e 
deve gerar como resultado um vetor que contenha a subtração do 
primeiro pelo segundo. Por exemplo $-12 - 1010 = -1022$:
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+---+ 
  -998: | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+ 
\end{verbatim}
\end{small}
\end{center}
Caso o resultado tenha mais bits que o espaço disponível no vetor
o procedimento deve descartar os bits excedentes. 

\item Escreva um programa em  
que leia uma sequência de $N$ valores
reais não nulos ($N \leq 100$) e os insira em um vetor.
A sequência termina quando o valor lido for 0. O elemento zero não faz
parte do vetor. Leia do teclado um inteiro $p$ ($p \leq N$) e
considere que o elemento $V[p]$ como o pivô na operação
de rearranjar o vetor de tal maneira que todos os elementos à
esquerda de $V[p]$ sejam menores que ele e todos os da direta sejam
maiores ou iguais a ele. Por exemplo, considere o seguinte vetor dado
como entrada: 
\begin{center}
\begin{small}
\begin{verbatim}
    +------+------+------+------+------+------+------+
    | 99.7 | 32.6 | 2.45 | 13.4 | 26.7 | 12.2 | 0.51 | 
    +------+------+------+------+------+------+------+
\end{verbatim}
\end{small}
\end{center}
e $P$ valendo 3, o programa deve gerar como resultado um vetor onde
todos os elementos que estão à esquerda do valor $2.45$ no vetor sâo menores
que ele, enquanto que os da direita são maiores do que ele.

\item Escreva uma função em  que procura uma palavra dentro
de um texto. A função deve receber como parâmetros:
\begin{itemize}
\item um vetor do tipo \verb+texto+ que contém um texto;
\item o tamanho do vetor que contém o texto;
\item a posição inicial da busca dentro do vetor que contém o 
texto;
\item um vetor do tipo \verb+texto+ que contém uma palavra;
\item o tamanho do vetor que contém a palavra.
\end{itemize}
A função deve retornar um número inteiro indicando a posição
no texto onde a palavra foi encontrada pela primeira vez. 

Caso a palavra não seja encontrada ou algum erro ocorra o 
valor retornado deve ser zero. A busca pela palavra no texto 
deve iniciar na posição passada como parâmetro para a função.

O tipo \verb+texto+ é dado por:
\begin{center}
\begin{small}
\begin{verbatim}
   const
      TAMMAX = 10000;

   type
      texto = array [1..TAMMAX] of char;

\end{verbatim}
\end{small}
\end{center}

\item Escreva um programa em  que gere e imprima um
vetor de números reais de tamanho $N$, $1 \le N \le MAX$. A criação
do vetor deve ser feita da seguinte maneira:
\begin{itemize}
\item O tamanho $N$ do vetor deve ser lido do teclado; 
\item Os $N$ números reais são gerados aleatoriamente no
intervalo $[R_{min},R_{max}[$, com $R_{min}$ e $R_{max}$ lidos do teclado;
\item A posição em que cada elemento real é inserida no vetor também é gerada
      aleatoriamente;
\item Se uma posição $i$ sorteada já estiver ocupada, seu algoritmo deve
encontrar a primeira posição $j$ não ocupada, iniciando a partir de $i+1$ até
o final do vetor. Se todas as posição entre $i+1$ e o final do vetor
estiverem ocupadas, seu algoritmo deve pegar a primeira posição livre a
partir do início do vetor.
\end{itemize}

Dica: a função \verb|random| sem parâmetros retorna um número real no intervalo
$[0,1[$, e a função \verb|random(n)| retorna um número inteiro no intervalo
$[0,n[$.

\item Escreva um procedimento em  que remove um
  elemento de uma determinada posição $p$ de um vetor $v$ de $n$ números
  reais. O vetor não está ordenado. 
  Use a seguinte assinatura para o procedimento: 

\verb!   procedure remove(var v: vetor; var n: integer; p: integer);!


\item Escreva um procedimento em  que altere um
  vetor de $N$ números reais da seguinte forma: todos os elementos
  repetidos do vetor devem ir para o final do vetor, mas de maneira
  que estes últimos fiquem em ordem crescente. Exemplos:

\verb!   ENTRADA: 5 3 8 2 3 9 8 9 7 5 3               ENTRADA: 4 4 3 3 2 2!

\vspace*{-1mm}
\verb!   SAÍDA  : 5 3 8 2 9 7 3 3 5 8 9               SAÍDA  : 4 3 2 2 3 4!

\item Em uma festa estiveram presentes 150 pessoas. Cada uma delas recebeu
um crachá na entrada com um número entre 1 e 150, número que
representa a ordem de entrada de cada convidado.

Como em toda festa, cada um dos presentes cumprimentou outras pessoas
com apertos de mão. Ao final da festa, cada convidado sabia exatamente
quantas vezes tinha apertado a mão de outras pessoas.

Na saída, ao entregar o crachá ao recepcionista, cada convidado
informou o número do seu crachá e quantas vezes trocou apertos de mão
na festa.

Muito curioso, o recepcionista queria saber quantos convidados eram
muito populares no encontro, isto é, queria saber o número de pessoas
que apertaram a mão de pelo menos outros 120 convidados.

Faça um programa
que modele o problema do recepcionista e que produza como saída o
número de celebridades (cumprimentadas pelo menos 120 vezes) presentes
na festa.

\item Um procedimento chamado \texttt{nova\_geracao} 
recebe como parâmetros dois  vetores (origem e  destino) e o
tamanho  dos vetores.  Este  procedimento constrói  um  novo vetor  de
valores  0 ou  1  (destino) a  partir  do conteúdo  do primeiro  vetor
(origem). Seja $O$ o vetor origem e $D$ o vetor destino, a regra para 
a construção do novo vetor é dada por:
\begin{itemize}
\item 
se: $O[i-1] = 0,\ O[i] = 0,\ O[i+1] = 0$ então: $D[i] = 0$
\item 
se: $O[i-1] = 0,\ O[i] = 0,\ O[i+1] = 1$ então: $D[i] = 1$
\item 
se: $O[i-1] = 0,\ O[i] = 1,\ O[i+1] = 0$ então: $D[i] = 1$
\item 
se: $O[i-1] = 0,\ O[i] = 1,\ O[i+1] = 1$ então: $D[i] = 1$
\item 
se: $O[i-1] = 1,\ O[i] = 0,\ O[i+1] = 0$ então: $D[i] = 1$
\item 
se: $O[i-1] = 1,\ O[i] = 0,\ O[i+1] = 1$ então: $D[i] = 0$
\item 
se: $O[i-1] = 1,\ O[i] = 1,\ O[i+1] = 0$ então: $D[i] = 0$
\item 
se: $O[i-1] = 1,\ O[i] = 1,\ O[i+1] = 1$ então: $D[i] = 0$
\end{itemize}
Onde $i$ indica uma posição do vetor $D$. Considere o valor 0 para as
bordas externas do vetor origem $O$. Escreva o procedimento
\texttt{nova\_geracao} e separe a regra descrita acima em uma função
que dados os valores das 3 posições consecutivas do vetor origem
($O[i-1], O[i], O[i+1]$) calcula o valor correspondente no vetor
destino ($D[i]$).

\item Faça um programa em  que simule o 
tráfego em um trecho de uma rodovia de mão única, ou seja, uma rodovia na 
qual os veículos entram de um lado e saem do outro. 

\begin{itemize}
    \item A rodovia é representada por um vetor com \verb|TAM_RODOVIA| posições;
    \item A simulação ocorre durante \verb|MAX_TEMPO| iterações;
    \item Através da chamada do procedimento \\
          \verb|detecta_entrada(VAR tipo, placa, velocidade:INTEGER)|,\\
          o programador é 
          informado sobre a ocorrência ou não da entrada de um veículo na
          rodovia, bem como o tipo do veículo, sua placa e sua respectiva 
          velocidade, onde:
        \begin{itemize}
            \item \emph{tipo:} $0$ - nenhuma nova entrada, 
                               $1$ - entrou automóvel, 
                               $2$ - entrou caminhão;
            \item \emph{placa:} um número inteiro;
            \item \emph{velocidade:} a velocidade de deslocamento do veículo 
                   (em posições/unidade de tempo).
        \end{itemize}
    \item Veículos do tipo automóvel ocupam uma posição da rodovia. 
          Caminhões ocupam duas posições.
    \item Quando veículos mais rápidos alcançam veículos mais lentos, os 
          primeiros devem andar mais devagar, pois não podem ultrapassar.
\end{itemize}    
    

A cada unidade de tempo em que algum veículo sair da rodovia, seu programa
deve imprimir esta unidade de tempo e o número da placa do veículo que saiu.

Exemplo: (\verb|TAM_RODOVIA=7|, \verb|MAX_TEMPO=10|)
\begin{itemize}
    \item Entrada:
    \begin{itemize}
        \item \textbf{t=1:} $tipo=2, placa=35, velocidade=1$
        \item \textbf{t=2:} $tipo=0$
        \item \textbf{t=3:} $tipo=1, placa=27, velocidade=4$
        \item \textbf{t=4:} $tipo=0$
        \item \textbf{t=5:} $tipo=0$
        \item \textbf{t=6:} $tipo=1, placa=16, velocidade=2$
        \item \textbf{t=7:} $tipo=0$
        \item \textbf{t=8:} $tipo=0$
        \item \textbf{t=9:} $tipo=0$
        \item \textbf{t=10:} $tipo=0$
    \end{itemize}

    \item Representação gráfica:

    \begin{itemize}
        \item \textbf{t=1:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $35_1$&$35_1$& & & & &\\ \hline \end{tabular}
        \item \textbf{t=2:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline &$35_1$& $35_1$& & & &\\ \hline \end{tabular}
        \item \textbf{t=3:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $27_4$& & $35_1$&$35_1$ & & &\\ \hline \end{tabular}
        \item \textbf{t=4:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & $27_4$& $35_1$& $35_1$& &\\ \hline \end{tabular}
        \item \textbf{t=5:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & $27_4$& $35_1$& $35_1$&\\ \hline \end{tabular} 
        \item \textbf{t=6:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $16_2$& & & & $27_4$& $35_1$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=7:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & &$16_2$ & & & $27_4$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=8:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & $16_2$& & $27_4$ \\ \hline \end{tabular}
        \item \textbf{t=9:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & & $16_2$ \\ \hline \end{tabular}
        \item \textbf{t=10:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & & \\ \hline \end{tabular}
    \end{itemize}

    \item Saída:
    \begin{itemize}
        \item \textbf{t=8:} $35$
        \item \textbf{t=9:} $27$
        \item \textbf{t=10:} $16$
    \end{itemize}
\end{itemize}

%\begin{lstlistings}[frame=trBL]
%Code
%\end{lstlistings}


\item Você deve incluir no enunciado da questão anterior a
existência de uma pista de ultrapassagem. Agora, veículos mais rápidos 
podem mover-se para a pista de ultrapassagem ao alcançarem veículos mais 
lentos, desde que não haja ninguém ocupando aquele trecho de pista. 
Eles devem retornar à pista original assim que tiverem completado 
a ultrapassagem, retomando a velocidade original. Você deve escrever unicamente
os procedimentos modificados ou novos que levam em conta este novo fato.

Exemplo da nova saída para a entrada original:
\begin{itemize}
    \item Representação gráfica:
    \begin{itemize}
        \item \textbf{t=1:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\
            \hline $35_1$&$35_1$& & & & &\\ \hline \end{tabular}
        \item \textbf{t=2:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline &$35_1$& $35_1$& & & &\\ \hline \end{tabular}
        \item \textbf{t=3:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline $27_4$& & $35_1$&$35_1$ & & &\\ \hline \end{tabular}
        \item \textbf{t=4:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & $27_4$& & &\\ 
            \hline & & & $35_1$& $35_1$& &\\ \hline \end{tabular}
        \item \textbf{t=5:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & $35_1$& $35_1$&$27_4$\\ \hline \end{tabular} 
        \item \textbf{t=6:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline $16_2$& & & & & $35_1$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=7:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & &$16_2$ & & & & $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=8:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & $16_2$& &  \\ \hline \end{tabular}
        \item \textbf{t=9:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & & & $16_2$ \\ \hline \end{tabular}
        \item \textbf{t=10:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & & & \\ \hline \end{tabular}
    \end{itemize}
    \item Saída:
    \begin{itemize}
        \item \textbf{t=6:} $27$
        \item \textbf{t=8:} $35$
        \item \textbf{t=10:} $16$
    \end{itemize}
\end{itemize}


\item Mateus, um engenheiro novato, está desenvolvendo uma notação posicional original
para representação de números inteiros. Ele chamou esta notação de UMC 
(Um método curioso). A notação UMC usa os mesmos dígitos da notação decimal,
isto é, de 0 a 9.
%
Para converter um número $A$ da notação UMC para a notação decimal deve-se
adicionar $K$ termos, onde $K$ é o número de dígitos de $A$ (na notação UMC).
O valor do $i$-ésimo termo correspondente ao $i$-ésimo dígito $a_i$, contando
da direita para a esquerda é $a_i \times i!$. 

Por exemplo, 719$_{UMC}$ é equivalente a 53$_{10}$, pois
$7 \times 3! + 1 \times 2! + 9 \times 1! = 53$.

Mateus está começando seus estudos em teoria dos números e 
provavelmente não sabe quais as propriedades que um sistema de numeração
deve ter, mas neste momento ele está interessado em converter
os números da notação UCM para a notação decimal. Você pode ajudá-lo?

\noindent
\textbf{Entrada}:
cada caso de teste é fornecido em uma linha simples que contém um 
número não vazio de no máximo 5 dígitos, representando um número 
em notação UMC. Este número não contém zeros a esquerda. O último
teste é sequido por uma linha contendo um zero.

\noindent
\textbf{Saída}:
para cada caso de teste imprimir uma linha simples contendo a representação
em notação decimal do correspondente número em UMC seguido do cálculo feito
para a conversão.

\noindent
\textbf{O programa}:
seu programa deve, para cada número da entrada, convertê-lo em um vetor
de inteiros, sendo que cada dígito do número é um elemento do vetor,
e fazer os cálculos usando este vetor. 

\noindent
Exemplos de entrada e saída:
\begin{verbatim}
ENTRADA                SAÍDA
719                    53 = 7 x 3! + 1 x 2! + 9 x 1!
1                      1 = 1 x 1!
15                     7 = 1 x 2! + 5 x 1!
110                    8 = 1 x 3! + 1 x 2! + 0 x 1!
102                    8 = 1 x 3! + 0 x 2! + 2 x 1!
0 
\end{verbatim}


\item Sabemos que nos compiladores  mais recentes, nos
  quais existe o tipo \textsf{string}, podemos realizar de maneira simples
   operações com  palavras.  Imagine, no entanto, que  estamos usando um
  compilador  \emph{Pascal}  no  qual  não  existe  este  tipo.  Neste  caso  o
  programador deve  implementar por  sua própria conta  os procedimentos
  com palavras. Neste exercício iremos considerar a seguinte 
  declaração alternativa para o tipo \textsf{string}: \\
\begin{center}
\verb+type palavra = array[1..MaxTam] of char;+ 
\end{center}
  Implemente uma função em \emph{Pascal} que receba
  como parâmetros duas variáveis do tipo \textsf{MeuString} e retorne -1 se a
  primeira palavra for lexicograficamente menor que a segunda, 0 se
  forem iguais, e +1 no caso que resta.



\item Faça um programa que leia um certo número indefinido de
vetores e que imprima o vetor original (O) e um vetor gerado (G)
após um processo de compactação
que consiste na eliminação de todos os elementos repetidos
em cada vetor. Considere que a entrada de dados é feita em
um vetor por linha, sendo que o primeiro elemento da linha é
o tamanho de cada vetor e os elementos restantes da linha são
os elementos do vetor. Quando o tamanho for zero significa que 
terminou a entrada de dados. Por exemplo, considere a seguinte
entrada:

\begin{verbatim}
5 2 4 7 -1 2
3 1 1 1 
7 3 4 5 3 4 5 1
0
\end{verbatim}

Deverá produzir como saída o seguinte:

\begin{verbatim}
O: 2 4 7 -1 2
G: 2 4 7 -1
O: 1 1 1
G: 1
O: 3 4 5 3 4 5 1
G: 3 4 5 1
\end{verbatim}

\item Considere uma sequência de dígitos binários como:

011100011

Uma maneira de criptografar essa sequência de bits é adicionar
à cada dígito a soma dos seus dígitos adjacentes. Por exemplo,
a sequência acima se tornaria:

123210122

Se $P$ é a sequência original e $Q$ é a sequência criptografada,
então $Q[i] = P[i-1] + P[i] + P[i+1]$ para todas as posições $i$
da sequência. Considerando uma sequência de tamanho $n$ e seus
índices variando de $0$ a $n-1$, os dígitos $P[-1]$ e $P[n]$ não
fazem parte da sequência original e são tratados como zeros na
operação de codificação.

Assumindo $P[0] = 0$ temos:
\begin{itemize}
\item
$Q[0] = P[0] + P[1] = 0 + P[1] = 1$, logo $P[1] = 1$.
\item
$Q[1] = P[0] + P[1] + P[2] = 0 + 1 + P[2] = 2$, logo $P[2] = 1$.
\item
$Q[2] = P[1] + P[2] + P[3] = 1 + 1 + P[3] = 3$, logo $P[3] = 1$.
\item
Repetindo a operação temos: $P[4] = 0$, $P[5] = 0$, $P[6] = 0$, $P[7] = 1$ e $P[8] = 1$.
\end{itemize}

Agora repetindo o mesmo processo para $P[0] = 1$ temos:
\begin{itemize}
\item
$Q[0] = P[0] + P[1] = 1 + P[1] = 1$, logo $P[1] = 0$.
\item
$Q[1] = P[0] + P[1] + P[2] = 1 + 0 + P[2] = 2$, logo $P[2] = 1$.
\item
$Q[2] = P[1] + P[2] + P[3] = 0 + 1 + P[3] = 3$, o que nos leva a conclusão que $P[3] = 2$.
Entretanto isso viola o fato da sequência original ser binária. Portanto não
existe uma decodificação possível considerando o primeiro dígito da sequência original
valendo $1$.
\end{itemize}
Note que este algoritmo pode gerar ou decodificar uma sequência criptografada em até duas 
possíveis sequências originais, uma iniciando com 0 e outra iniciando com 1.

Escreva um procedimento em  que receba como parâmetros um vetor de
números inteiros contendo a sequência criptografada e a decodifica em dois outros
vetores de números inteiros. Caso uma das decodificações não seja possível, como
no caso do exemplo para $P[0] = 1$, o vetor correspondente deve ser preenchido com -1
na posição inicial.

Outros exemplos:
\begin{itemize}
\item
$123210122 = 011100011, -1$
\item
$11 = 01, 10$
\item
$22111 = -1, 11001$
\item
$123210120 = -1, -1$
\item
$3 = -1, -1$
\item
$12221112222221112221111111112221111 = \\
01101001101101001101001001001101001, \\
10110010110110010110010010010110010$
\end{itemize}

\item Escrever um programa para ler um texto e imprimir uma distribuição de
   frequências para  palavras do texto  (quantas palavras de  uma letra,
   quantas de duas letras, etc.).


\item Escreva um programa em \emph{Pascal} que leia do teclado o gabarito de uma prova
de 20 questões de múltipla escolha, onde as respostas são inteiros de 1 a
5.  Em seguida, o programa deve ler o número de alunos que prestaram a prova
e, para cada aluno, a sua matrícula (um inteiro) e as respectivas respostas.
O programa deve calcular e escrever:
\begin{itemize}
\item a relação de alunos ordenados pela nota, supondo que cada questão vale 5 pontos;
\item para cada questão: quantos alunos acertaram a questão
\end{itemize}




\end{enumerate}
\item Dado o programa em \emph{Pascal} abaixo, mostre o acompanhamento de sua 
execução para três valores de entrada (valores pequenos, por exemplo para 
$x=0$, $x=10$ e $x=-1$).
Em seguida, descreva o que o programa faz.

\begin{lstlisting}
program questao1;
var
  m, x, y: integer;
begin
  read(x);
  y := 0;
  m := 1;
  while x > 0 do
    begin
      y := y + (x mod 2) * m;
      x := x div 2;
      m := m * 10;
    end;
  writeln(y)
end.
\end{lstlisting}

\item Fazer um programa em \emph{Pascal} para ler do teclado
um número inteiro $m$ e em seguida
uma sequência de $m$ números reais e imprimir a média aritmética deles.
Isto é, dados os números $N_1, N_2, \ldots, N_m$, calcular:

\[
\frac{N_1 + N_2 + \ldots + N_m}{m}
\]

\item Fazer um programa em \emph{Pascal} para calcular
o produto dos números ímpares de $A$ até $B$,
onde $A \le B$ são lidos do teclado. Considere que $A$ e $B$ são
sempre ímpares. Isto é, calcular:

\[
A \times (A+2) \times (A+4) \times \ldots \times B
\]

\item Fazer um programa em \emph{Pascal} para
     calcular o  valor da  soma dos  quadrados dos  primeiros  50 inteiros
     positivos não nulos.

\[
\sum_{i=1}^{50}{i^2} = 1^2 + 2^2 + 3^2 + \ldots + 50^2
\]

\item Ler um inteiro positivo N diferente de zero e calcular a soma:
   $1^{3} + 2^{3} + ... + N^{3}$.

\item Fazer um programa em \emph{Pascal} que,
    dados dois números inteiros positivos, determine quantas vezes o
    primeiro  divide exatamente  o segundo.  Se o  primeiro não  divide o
    segundo o número de vezes é zero. Por exemplo, 72 pode ser dividido
    exatamente por 3 duas vezes.

\begin{minipage}{5cm}
\begin{verbatim}
Entrada:
72 3
\end{verbatim}
\end{minipage} \
\begin{minipage}{5cm}
\begin{verbatim}
Saída:
2
\end{verbatim}
\end{minipage}

\item
Uma agência governamental deseja conhecer a distribuição da população do
país por faixa salarial. Para isto, coletou dados do
último censo realizado e criou um arquivo contendo, em cada linha, a
idade de um cidadão particular e seu salário. As idades variam de zero a
110 e os salários variam de zero a 19.000,00 unidades da moeda local
(salário do seu dirigente máximo). Considere o salário mínimo igual a 450,00 unidades da moeda local.

As faixas salariais de interesse são as seguintes:
\begin{itemize}
\item de 0 a 3 salários mínimos
\item de 4 a 9 salários mínimos
\item de 10 a 20 salários mínimos
\item acima de 20 salários mínimos.
\end{itemize}
Fazer um programa em \emph{Pascal} que leia o arquivo de entrada e produza como
saída os percentuais da população para cada faixa salarial
de interesse. A última linha, que não deve ser processada, contém dois zeros.

\begin{minipage}{5cm}
\begin{verbatim}
Entrada:
25 240.99
48 2720.77
37 4560.88
34 19843.33
23 834.15
90 315.87
78 5645.80
44 150.33
56 2560.00
67 2490.05
0 0.00  
\end{verbatim}
\end{minipage} \
\begin{minipage}{5cm}
\begin{verbatim}
Saída:
4%
3%
2%
1%
\end{verbatim}
\end{minipage}

\item (*) Escrever um programa em \emph{Pascal} que leia do teclado
uma sequência de números inteiros até que seja lido um número
que seja o dobro ou a metade do anteriormente lido.
O programa deve imprimir na saída os seguintes valores:
\begin{itemize}
\item a quantidade de números lidos;
\item a soma dos números lidos;
\item os dois valores lidos que forçaram a parada do programa.
\end{itemize}

Exemplo 1:
\begin{verbatim}
Entrada:
-549 -716 -603 -545 -424 -848
Saída:
6 -3685 -424 -848
\end{verbatim}

Exemplo 2:
\begin{verbatim}
Entrada
-549 -716 -603 -545 -424 646 438 892 964 384 192
Saída
11 679 384 192
\end{verbatim}

\item  Aqui temos uma forma peculiar de realizar uma multiplicação entre
dois números: multiplique o primeiro por 2 e divida o segundo por 2
até que o primeiro seja reduzido a 1. Toda vez que o primeiro for
impar, lembre-se do segundo. Não considere qualquer fração durante
o processo. O produto dos dois números é igual a soma dos números
que foram lembrados. Exemplo: $53 \times 26 =$

\begin {tabbing}
00012345\=10002345\=10002345\=10002345\=12000345\=12000345\=12000345\=12300045\=12345\=12345\=12345 \kill
53 \> 26 \> 13 \> 6 \> 3 \> 1 \\
26 \> 52 \> 104 \> 208 \> 416 \> 832 \\
\\
26 + \> \> 104 + \> \> 416 + \> 832 = 1378
\end {tabbing}

Fazer um programa em \emph{Pascal}
que receba dois números inteiros e retorne o produto deles
do modo como foi especificado acima.

\begin{minipage}{5cm}
\begin{verbatim}
Entrada:
53
26
\end{verbatim}
\end{minipage} \
\begin{minipage}{5cm}
\begin{verbatim}
Saída:
1378
\end{verbatim}
\end{minipage}

\item Fazer um programa em \emph{Pascal} para
    ler  uma massa de dados onde  cada linha contém dois  valores numéricos
    sendo o primeiro do tipo real e o segundo do tipo inteiro. O segundo
    valor é o peso atribuído ao primeiro valor. O
    programa deve calcular a média ponderada dos diversos valores lidos.
    A última
    linha de  dados contém os  únicos números zero.  Esta linha não  deve ser
    considerada no cálculo da média. Isto é, calcular o seguinte, supondo
    que $m$ linhas foram digitados:

\[
\frac{N_1 \times P_1 + N_2 \times P_2 + \ldots + N_m \times P_m}{P_1 + 
 P_2 + \ldots P_m}
\]
\begin{minipage}{5cm}
\begin{verbatim}
Entrada:
60 1
30 2
40 3
0 0
\end{verbatim}
\end{minipage} \
\begin{minipage}{5cm}
\begin{verbatim}
Saída:
40
\end{verbatim}
\end{minipage}


\item Dado um número de três dígitos, construir outro número de quatro
   dígitos com a seguinte regra: a) os três primeiros  dígitos,
   contados da esquerda para a direita, são iguais aos do número dado;
   b) o quarto dígito e' um dígito de controle calculado da seguinte forma:
   primeiro dígito + 3*segundo dígito + 5*terceiro dígito; o dígito de
   controle é igual ao resto da divisão dessa soma por 7.

\item Dado um  número inteiro  de  cinco dígitos  representando um  número
   binário, determinar seu valor equivalente em decimal. Por exemplo, se a
   entrada for 10001, a saída deve ser 17.

\item Considere o programa feito para resolução do cálculo do número neperiano
      (seção~\ref{sec_neperiano}.
     Quantas operações de multiplicação sao executadas no seu programa?
\begin{enumerate}
\item Considerando 20 termos.
\item Considerando N termos.
\end{enumerate}

\item Considere a progressão geométrica 1, 2, 4, 8, 16, 32, ... e um inteiro 
   positivo N. Imprimir os N primeiros termos desta PG e a soma deles.

\item Imprimir os N primeiros termos das sequências definidas pelas relações
   de recorrência:

\begin{enumerate}
\item $Y(k+1) = Y(k) + k, k = 1,2,3..., Y(1)=1$
\item $Y(k+1) = Y(k) + (2k+1), k = 0,1,2,3..., Y(0)=1$
\item $Y(k+1) = Y(k) + (3k^2 + 3k + 1), k = 0,1,2,3..., Y(0)=1$
\item $Y(k+1) = 2Y(k), k = 1,2,3..., Y(1)=1$
\end{enumerate}

\item Dado um número  inteiro $N$,  tabelar $N[k]$  para $k$  variando de  1 até
     $N$.  Considere  que,  por definição,  $X[k]=X(X-1)(X-2)(X-3)...(X-k+1)$,  
     $X$
     sendo um número  real, $k$ um natural diferente de  zero e $X[0]=1$. 
     Observe que se $X=N=k$, então $N[N]=N!$. 

\item Sabe-se  que o valor do coseno  de 1 (um) radiano  pode ser calculado
    pela série infinita abaixo:


\begin{center}
\[
coseno(x) = \frac{1}{0!} - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} 
           + \ldots
\]
\end{center}

    Fazer um  programa que calcule o  valor do cosseno de $x$ 
    obtido  pela série acima considerando somente os primeiros 14  
    termos da mesma.

\item Considere o conjunto $C$ de todos os números inteiros com quatro algarismos
distintos, ordenados segundo seus valores, em ordem crescente:
\begin{displaymath}
C = \{1023, 1024, 1025, 1026, 1027, 1028, 1029, 1032, 1034, 1035, \dots\}
\end{displaymath}

\vspace{-.2cm}
Faça um programa em \emph{Pascal} que leia um número $N$, pertencente a este
conjunto, e imprima a posição deste número no conjunto.

Exemplos:

\vspace{.1cm}
\begin{minipage}{2in}
\begin{itemize}
\item
Entrada: 1026\\
Saída: 4
\vspace{-.2cm}
\item
Entrada: 1034\\
Saída: 9
\end{itemize}
\end{minipage}
\begin{minipage}{2in}
\begin{itemize}
\item
Entrada: 9876\\
Saída: 4536
\vspace{-.2cm}
\item
Entrada: 1243\\
Saída: 72
\end{itemize}
\end{minipage}

\item Faça um programa em \emph{Pascal} que calcule e imprima o valor de $f(x)$, onde $x\in\Re$ é lido no teclado e:
\begin{equation*}
 f(x) = \frac{5x}{2!} - \frac{6x^2}{3!} + \frac{11x^3}{4!} - \frac{12x^4}{5!} + \frac{17x^5}{6!} - \frac{18x^6}{7!} + \ldots
\end{equation*}
O cálculo deve parar quando $abs(f(x_{n+1})-f(x_n)) < 0.00000001$, onde $abs(x)$ é a função em \emph{Pascal} que retorna o valor absoluto de $x$.

\item O número áureo $\varphi$ (1,6180339...) pode ser calculado através de
expressões com séries de frações sucessivas do tipo:
\begin{eqnarray*}
   \varphi_1 &=& 1 + \frac{1}{1}\ =\ 2 \\
   \varphi_2 &=& 1 + \frac{1}{1 + \frac{1}{1}}\ =\ 1,5 \\
   \varphi_3 &=& 1 + \frac{1}{1 + \frac{1}{1 + \frac{1}{1}}}\ =\ 1,666 \\
   \varphi_4 &=& 1 + \frac{1}{1 + \frac{1}
                {1 + \frac{1}{1 + \frac{1}{1}}}}\ =\ 1,6
\end{eqnarray*}
onde $\varphi_i$ indica a aproximação do número áureo com $i$ frações
sucessivas. Estes valores variam em torno do número áureo, sendo maior ou
menor alternadamente, mas sempre se aproximando deste quando o número
de frações cresce.

Faça um programa em \emph{Pascal} que leia um número $N$ e imprima o
valor da aproximação do número áureo $\varphi_N$, que usa uma série de
$N$ frações sucessivas.

\item Dado um inteiro positivo $N$ e dada uma sequência de $N$ números reais $x_1, \ldots, x_n$
faça um programa em \emph{Pascal} que calcule o quociente da soma dos reais pelo seu produto. Isto é:

\[
q=\frac{\sum_{i=1}^{N}{x_i}}{\prod_{i=1}^{N}x_i}
\]

Como não pode haver divisão por zero, seu programa deve parar tão logo esta situação seja
verificada indicando uma mensagem apropriada para o usuário.

\item Em \emph{Pascal} o tipo \textit{CHAR} é enumerável, e portanto está na classe dos tipos
chamados de \textit{ordinais}, conforme o guia de referência da linguagem estudado em
aula. A ordem de cada caracter é dada pela tabela ASCII. Assim é possível, por exemplo, escrever
trechos de códico tais como:

\vspace*{\baselineskip}

\begin{center}
\begin{minipage}{8cm}
\begin{verbatim}
IF 'A' > 'B' THEN
     WRITE ('A eh maior que B')
ELSE
     WRITE ('A não eh maior que B');
\end{verbatim}
\end{minipage}
\end{center}

\vspace*{\baselineskip}

\noindent que  produziria a mensagem ``A não eh maior que B'',
pois na tabela ASCII o símbolo ``A'' tem ordem 64 enquanto que ``B'' tem ordem 65.

Ou ainda:

\vspace*{\baselineskip}

\begin{center}
\begin{minipage}{8cm}
\begin{verbatim}
FOR i:= 'a' TO 'z' DO
     WRITE (i);
\end{verbatim}
\end{minipage}
\end{center}

\vspace*{\baselineskip}

\noindent que produziria como saída ``abcdefghijklmnopqrstuvxwyz''.

Faça um programa em \emph{Pascal} que leia seu nome completo (nomes completos em geral) constituídos
por apenas letras maiúsculas entre ``A'' e ``Z'' e espaços em branco terminadas em ``.'' e que
retorne o número de vogais e consoantes neste nome. Exemplos:

\vspace*{\baselineskip}

\begin{minipage}{8cm}
\begin{verbatim}
Entrada: FABIANO SILVA.
Saída: 
     Vogais: 6
     Consoantes: 6

Entrada: MARCOS ALEXANDRE CASTILHO.
Saída: 
     Vogais: 9
     Consoantes: 14

\end{verbatim}
\end{minipage}

\item Faça um  programa em \emph{Pascal} que leia um inteiro positivo $n$, e escreva
a soma dos $n$ primeiros termos da série:

\[ \frac{1000}{1} - \frac{997}{2} + \frac{994}{3} - \frac{991}{4} + \ldots\]

\item Dizemos que uma sequência de inteiros é {\bf $k$-alternante} se for
composta alternadamente por segmentos de números pares de tamanho $k$ e
segmentos de números ímpares de tamanho $k$.

Exemplos:

\noindent
A sequência 1 3 6 8 9 11 2 4 1 7 6 8 é 2-alternante. \\
A sequência 2 1 4 7 8 9 12 é 1-alternante.  \\
A sequência 1 3 5 é 3-alternante.

Escreva um programa \emph{Pascal} que verifica se uma sequência de tamanho $n$ é
10-alternante.  O programa deve ler $n$, o tamanho da sequência, no inicío do
programa e aceitar somente valores  múltiplos de 10.
A saída do programa deve ser a mensagem  ``{\tt A sequencia eh
10-alternante}'' caso a sequência seja 10-alternante e ``{\tt A sequencia
nao eh 10-alternante}'', caso contrário.


\item Faça um  programa em \emph{Pascal} que calcule
 o resultado da seguinte série:

\[
S = \frac{x^0}{2!} - \frac{x^4}{6!} + \frac{x^8}{10!} - \frac{x^{12}}{14!} + \frac{x^{16}}{18!} - \ldots
\]


\item Faça um programa em \emph{Pascal} que
receba como entrada um dado
inteiro $N$ e o imprima como um produto de primos. Exemplos:
$45 = 3 \times 3 \times 5$. $56 = 2 \times 2 \times 2 \times 7$.

\item Faça um programa em \emph{Pascal} que calcule e escreva o
 valor de $S$ assim definido:

 \[ 
        S = \frac {1}{1!} - \frac {2}{2!} + \frac {4}{3!}  - \frac
        {8}{2!} + \frac {16}{1!} - \frac {32}{2!} + \frac {64}{3!} -
        \cdots 
 \]

\item Fazer  um  programa em  \emph{Pascal}  que calcule e escreva o valor de S:
\[
    S = \frac {37 \times 38}{1} + \frac {36 \times 37}{2} + \frac {35 \times 36}{3} + 
        \cdots + \frac{1 \times 2}{37}
\]


\end{enumerate}
\item Escreva um programa em \emph{Pascal} que leia um número e o imprima 
caso ele seja maior que 20.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
30.56           & 30.56          \\ \hline
20              &                \\ \hline
20.05           & 20.05          \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia dois valores numéricos 
inteiros e efetue a adição; se o resultado for maior que 10, imprima o 
primeiro valor. Caso contrário, imprima o segundo.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
7                &                \\
4                &   7             \\ \hline
7                &                \\
2                &   2             \\ \hline
3                &                \\
7                &   7             \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que imprima se um dado número $N$ 
inteiro (recebido através do teclado) é PAR ou ÍMPAR.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5                & impar               \\ \hline
3                & impar               \\ \hline
2                & par               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} para determinar se um dado número 
$N$ (recebido através do teclado) é POSITIVO, NEGATIVO ou NULO.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5               & positivo               \\ \hline
-3              & negativo               \\ \hline
0               & nulo               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia dois números e efetue a 
adição. Caso o valor somado seja maior que 20, este deverá ser apresentado 
somando-se a ele mais 8; caso o valor somado seja menor ou igual a 20, 
este deverá ser apresentado subtraindo-se 5.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
13.14                &                \\
5                &    13.14            \\ \hline
-3                &                \\
-4                &   -12.00             \\ \hline
16                &                \\
5                &    20.00            \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que imprima qual o menor valor de 
dois números $A$ e $B$, lidos através do teclado.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5.35                &                \\
4                & 4.00               \\ \hline
-3                &                \\
1                & -3.00               \\ \hline
6                &                \\ 
15                & 6.00               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} para determinar se um número 
inteiro $A$ é divisível por um outro número inteiro $B$. Esses valores 
devem ser fornecidos pelo usuário.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5                &                \\
10               & nao               \\ \hline
4                &                \\ 
2                & sim               \\ \hline
7                &                \\ 
21               & nao              \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia um número inteiro e 
informe se ele é ou não divisível por 5.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5                & sim               \\ \hline
-5                & sim               \\ \hline
3                &  nao              \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que receba um número inteiro e 
imprima se este é múltiplo de 3.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5                & nao               \\ \hline
-3                & sim               \\ \hline
15                & sim               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia um número e imprima a 
raiz quadrada do número caso ele seja positivo ou igual a zero e o quadrado 
do número caso ele seja negativo.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
0                & 0.00               \\ \hline
4                & 2.00               \\ \hline
-5               & 25.00               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia um número e informe se ele 
é divisível por 3 e por 7.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
21               & sim               \\ \hline
7                & nao               \\ \hline
3                & nao               \\ \hline
-42              & sim               \\ \hline
\end{tabular}
\end{center}

\item A prefeitura de Contagem abriu uma linha de crédito para os funcionários 
estatutários. O valor máximo da prestação não poderá ultrapassar 30\% do 
salário bruto. Fazer um programa em \emph{Pascal} que permita entrar com o 
salário bruto e o valor da prestação, e informar se o empréstimo pode ou não 
ser concedido.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
500                &                \\
200                & nao               \\ \hline
1000.50                &                \\
250.10                & sim               \\ \hline
1000                &                \\
300                & sim               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que dado quatro valores, 
$A$, $B$, $C$ e $D$, o programa imprima o menor e o maior valor.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
1                &                \\ 
2                &                \\ 
3                &                \\ 
4                & 1.00 4.00               \\ \hline
-3                &                \\ 
0               &                \\ 
1               &                \\ 
1               &  -3.00 1.00              \\ \hline
3.5                &                \\
3.7                &                \\
4.0                &                \\
5.5                & 3.50 5.50               \\ \hline
\end{tabular}
\end{center}

\item Dados três valores $A$, $B$ e $C$, construa um programa em \emph{Pascal},
 que imprima os valores de forma ascendente (do menor para o maior).

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
1 2 1.5                & 1.00 1.50 2.00               \\ \hline
-3 -4 -5              & -5.00 -4.00 -3.00               \\ \hline
6 5 4                & 4.00 5.00 6.00               \\ \hline
\end{tabular}
\end{center}

\item Dados três valores $A$, $B$ e $C$, construa um programa em \emph{Pascal},
 que imprima os valores de forma descendente (do maior para o menor).

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
1 2 1.5                & 2.00 1.50 1.00               \\ \hline
-5 -4 -3                & -3.00 -4.00 -5.00                \\ \hline
5 6 4                & 6.00 5.00 4.00               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia dois números e imprimir 
o quadrado do menor número e raiz quadrada do maior número, se for possível.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
4                &                \\
3                & 9.00 2.00               \\ \hline
4.35                &                \\
3.50                & 12.25 2.09              \\ \hline
-4                &                \\ 
-16                & 256.00               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que indique se um número digitado 
está compreendido entre 20 e 90 ou não (20 e 90 não estão na faixa de valores).

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
50.50                & sim               \\ \hline
20                & nao               \\ \hline
90                & nao               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia um número inteiro e 
informe se ele é divisível por 10, por 5 ou por 2 ou se não é divisível 
por nenhum deles.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
10                &  10 5 2              \\ \hline
5                &  5              \\ \hline
4                &  2              \\ \hline
7               &  nenhum              \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia um número e imprima se 
ele é igual a 5, a 200, a 400, se está no intervalo entre 500 e 1000, 
inclusive, ou se está fora dos escopos anteriores.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5                & igual a 5               \\ \hline
200                & igual a 200               \\ \hline
400                & igual a 400               \\ \hline
750.50                & intervalo entre 500 e 1000               \\ \hline
1000                & intervalo entre 500 e 1000               \\ \hline
1500                & fora dos escopos               \\ \hline
\end{tabular}
\end{center}

\item A CEF concederá um crédito especial com juros de 2\% aos seus clientes de 
acordo com o saldo médio no último ano. Fazer um programa em \emph{Pascal} que 
leia o saldo médio de um cliente e calcule o valor do crédito de acordo com a 
tabela a seguir. Imprimir uma mensagem informando o valor de crédito.

\begin{tabular}{|l|l|}\hline
De 0 a 500 & nenhum credito \\ \hline
De 501 a 1000 & 30\% do valor do saldo medio \\ \hline
De 1001 a 3000 & 40\% do valor do saldo medio \\ \hline
Acima de 3001 &  50\% do valor do saldo medio\\ \hline
\end{tabular}

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
300.50                & 0.00                \\ \hline
571                & 171.30               \\ \hline
1492.35                & 596.94               \\ \hline
3001.20               &  1500.60               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que dada a idade de uma pessoa, 
determine sua classificação segundo a seguinte tabela:
\begin{itemize}
\item Maior de idade;
\item Menor de idade;
\item Pessoa idosa (idade superior ou igual a 65 anos).
\end{itemize}

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
18                & maior               \\ \hline
15                & menor               \\ \hline
65                & idosa               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia a idade de uma pessoa 
e informe a sua classe eleitoral:
\begin{itemize}
\item não eleitor (abaixo de 16 anos);
\item eleitor obrigatório (entre a faixa de 18 e menor de 65 anos);
\item eleitor facultativo (de 16 até 18 anos e maior de 65 anos, inclusive).
\end{itemize}

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
15                & nao eleitor               \\ \hline
16                & facultativo               \\ \hline
17                & facultativo               \\ \hline
18                & obrigatorio               \\ \hline
19                & obrigatorio               \\ \hline
\end{tabular}
\end{center}

\item A confederação brasileira de natação irá promover eliminatórias para o próximo mundial. Fazer um programa em \emph{Pascal} que receba a idade de um nadador e imprima a sua categoria segundo a tabela a seguir:

\begin{tabular}{|l|l|} \hline
Infantil A & 5 -- 7 anos \\ \hline
Infantil B & 8 -- 10 anos  \\ \hline
Juvenil A & 11 -- 13 anos \\ \hline
Juvenil B & 14 -- 17 anos \\ \hline
Sênior &  Maiores de 18 anos \\ \hline
\end{tabular}

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
4 & INVÁLIDO \\ \hline
7 & Infantil A \\ \hline
8 & Infantil B \\ \hline
10 & Infantil B \\ \hline
11 & Juvenil A \\ \hline
13 & Juvenil A \\ \hline
14 & Juvenil B \\ \hline
17 & Juvenil B \\ \hline
18 & Sênior \\ \hline
\end{tabular}
\end{center}

\item Dados três valores $A$, $B$ e $C$, escreva um programa em \emph{Pascal} 
para verificar se estes valores podem ser valores dos lados de um triângulo, 
se é um triângulo ESCALENO, um triângulo EQUILÁTERO ou um triângulo ISÓSCELES. 
Caso não sejam válidos, imprimir: ``INVALIDO''.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5 & \\
5 & \\
5 & EQUILATERO \\ \hline
7 & \\
7 & \\
5 & ISOSCELES \\ \hline
3 & \\
4 & \\
5 & ESCALENO \\ \hline
5 & \\
4 & \\
15 & INVALIDO \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia as duas notas bimestrais 
de um aluno e determine a média das notas semestral. Através da média 
calculada o algoritmo deve imprimir a seguinte mensagem: APROVADO, 
REPROVADO ou em EXAME (a média é 7 para Aprovação, menor que 3 para 
Reprovação e as demais em Exame).

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
3.1 & \\
2.5 & REPROVADO \\ \hline
3 & \\
3 & EXAME \\ \hline
10 & \\
0 & EXAME \\ \hline
6 & \\
8 & APROVADO \\ \hline
10 & \\
10 & APROVADO \\ \hline
\end{tabular}
\end{center}

\item Depois da liberação do governo para as mensalidades dos planos de saúde, as pessoas começaram a fazer pesquisas para descobrir um bom plano, não muito caro. Um vendedor de um plano de saúde apresentou a tabela a seguir. Escreva um programa em \emph{Pascal} que entre com a idade de uma pessoa e imprima o valor que ela deverá pagar, segundo a seguinte tabela:

\begin{tabular}{|l|l|}
Até 10 anos & R\$ 30.00 \\ \hline
Acima de 10 até 29 anos & R\$ 60.00 \\ \hline
Acima de 29 até 45 anos & R\$ 120.00 \\ \hline
Acima de 45 até 59 anos & R\$ 150.00 \\ \hline
Acima de 59 até 65 anos & R\$ 250.00 \\ \hline
Maior do que 65 anos & R\$ 400.00 \\ \hline
\end{tabular}

\begin{center}
\begin{tabular}{|l|l|} \hline
10 & R\$ 30,00 \\ \hline
29 & R\$ 60,00 \\ \hline
45 & R\$ 120,00 \\ \hline
59 & R\$ 150,00 \\ \hline
65 & R\$ 250,00 \\ \hline
66 & R\$ 400,00 \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia o um número inteiro entre 1 e 7 e escreva o dia da semana correspondente. Caso o usuário digite um número fora desse intervalo, deverá aparecer a seguinte  mensagem: INEXISTENTE

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
0 & INEXISTENTE \\ \hline
1 & DOMINGO \\ \hline
2 & SEGUNDA \\ \hline
3 & TERÇA \\ \hline
4 & QUARTA \\ \hline
5 & QUINTA \\ \hline
6 & SEXTA \\ \hline
7 & SÁBADO \\ \hline
8 & INEXISTENTE \\ \hline
\end{tabular}
\end{center}
\item Escreva um programa em \emph{Pascal} que leia um número inteiro e 
imprima o seu sucessor e seu antecessor, na mesma linha.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
1               & 2 0 \\ \hline
100             & 101 99 \\ \hline
-3              & -2 -4 \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia dois números inteiros e 
imprima o resultado da soma destes dois valores. Antes do resultado, deve ser 
impressa a seguinte mensagem ``SOMA= ''.


\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
1 2             & SOMA= 3 \\ \hline
100 -50         & SOMA= 50 \\ \hline
-5 -40          & SOMA= -45 \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia dois números reais, um 
será o valor de um produto e outro o valor de desconto que esse produto está 
recebendo. Imprima quantos reais o produto custa na promoção.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
Valor original & Desconto & Valor na promoção \\ \hline
500.00         & 50.00  & 450.00 \\ \hline
10500.00       & 500.00 & 10000.00\\ \hline
90.00          & 0.80   & 89.20 \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia dois números reais e 
imprima a média aritmética entre esses dois valores.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
1.2 2.3         & 1.75 \\ \hline
750 1500        & 1125.00  \\ \hline
8900 12300      & 10600.00 \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia um número real e imprima a 
terça parte deste número.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
3               & 1.00 \\ \hline
10              & 3.33  \\ \hline
90              & 30.00 \\ \hline
\end{tabular}
\end{center}

\item Uma P.A. (progressão aritmética) fica determinada pela sua razão ($r$) 
e pelo primeiro termo ($a_1$). Escreva um programa em \emph{Pascal} que seja 
capaz de determinar o enésimo ($n$) termo ($a_n$) de uma P.A., dado a razão 
($r$) e o primeiro termo ($a_1$). Seu programa deve ler $n, r, a_1$ do teclado
e imprimir $a_n$.

\[
a_n = a_1 + (n-1)\times r.
\]

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$n$ & $r$ & $a_1$   & $a_n$               \\ \hline
8 & 1 & 3       & 10                \\ \hline
100 & 10 & 1    & 991                \\ \hline
5 & -2 & 0      & -98                \\ \hline
\end{tabular}
\end{center}

\item Dada a razão ($r$) de uma P.A. (progressão aritmética) e um termo 
qualquer, $k$ ($a_k$). Escreva um programa em \emph{Pascal} para calcular 
o enésimo termo $n$ ($a_n$). Seu programa deve ler $k, a_k, r, n$ do teclado
e imprimir $a_n$.

\[
a_n = a_k + (n-r) \times r
\]

\begin{center}
\begin{tabular}{|l|l|l|l|l|} \hline
\multicolumn{4}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$k$ & $a_k$ & $r$ & n   & $a_n$             \\ \hline
1 & 5 & 2 & 10          & 23                \\ \hline
10 & 20 & 2 & 5         & 10                \\ \hline
100 & 500 & 20 & 90     & 300               \\ \hline
\end{tabular}
\end{center}

\item Uma P.G. (progressão geométrica) fica determinada pela sua razão ($q)$ 
e pelo primeiro termo ($a_1$). Escreva um programa em \emph{Pascal} que seja 
capaz de determinar o enésimo $n$ termo ($a_n$) de uma P.G., dado a razão ($q$) 
e o primeiro termo ($a_1$). Seu programa deve ler $a_1, q, n$ do teclado
e imprimir $a_n$.

\[
a_n = a_1 \times q^{(n-1)}.
\]

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$a_1$ & $q$ & $n$   & $a_n$               \\ \hline
1 & 1 & 100         & 1.00                \\ \hline
2 & 2 & 10          & 1024.00             \\ \hline
5 & 3 & 2           & 15.00               \\ \hline
\end{tabular}
\end{center}

\item Dada a razão ($q$) de uma P.G. (progressão geométrica) e um termo 
qualquer, $k$ ($a_k$). Escreva um programa em Pascal para calcular o enésimo 
termo $n$ ($an$). Seu programa deve ser $k, a_k, q, n$ do teclado e imprimir
$a_n$.

\begin{center}
\begin{tabular}{|l|l|l|l|l|} \hline
\multicolumn{4}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$k$ & $a_k$ & $q$ & $n$  & $a_n$               \\ \hline
2 & 2 & 1 & 1        & 2                \\ \hline
1 & 5 & 2 & 10       & 2560.00             \\ \hline
2 & 100 & 10 & 20    & 100000000000000000000.00               \\ \hline
\end{tabular}
\end{center}

\item Uma P.G. (progressão geométrica) fica determinada pela sua razão ($q$) 
e pelo primeiro termo ($a_1$). Escreva um programa em \emph{Pascal} que 
seja capaz de determinar o enésimo termo ($a_n$) de uma P.G., dado a razão 
($q$) e o primeiro termo ($a_1$). Seu programa deve ler $a_1, q, n$ do 
teclado e imprimir $a_n$.

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$a_1$ & $q$ & $n$   & $a_n$               \\ \hline
1 & 1 & 100         & 1.00                \\ \hline
2 & 2 & 10          & 1024.00             \\ \hline
10 & 2 & 20         & 5242880.00          \\ \hline
\end{tabular}
\end{center}

\item Considere que o número de uma placa de veículo é composto por quatro 
algarismos. Escreva um programa em \emph{Pascal} que leia este número  do
teclado e apresente o algarismo correspondente à casa das unidades.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
2569                & 9               \\ \hline
1000                & 0               \\ \hline
1305                & 5               \\ \hline
\end{tabular}
\end{center}

\item Considere que o número de uma placa de veículo é composto por quatro 
algarismos. Escreva um programa em \emph{Pascal} que leia este número  do
teclado e apresente o algarismo correspondente à casa das dezenas.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
2569                & 6               \\ \hline
1000                & 0               \\ \hline
1350                & 5               \\ \hline
\end{tabular}
\end{center}

\item Considere que o número de uma placa de veículo é composto por quatro 
algarismos. Escreva um programa em \emph{Pascal} que leia este número  do
teclado e apresente o algarismo correspondente à casa das centenas.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
2500                & 5               \\ \hline
2031                & 0               \\ \hline
6975                & 9               \\ \hline
\end{tabular}
\end{center}

\item Considere que o número de uma placa de veículo é composto por quatro 
algarismos. Escreva um programa em \emph{Pascal} que leia este número  do
teclado e apresente o algarismo correspondente à casa do milhar.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
2569                & 2               \\ \hline
1000                & 1               \\ \hline
0350                & 0               \\ \hline
\end{tabular}
\end{center}

\item Você é um vendedor de carros é só aceita pagamentos à vista. As vezes 
é necessário ter que dar troco, mas seus clientes não gostam de notas miúdas. i
Para agradá-los você deve criar um programa em \emph{Pascal} que recebe o valor
do troco que deve ser dado ao cliente e retorna o número de notas de R\$100 
necessárias para esse troco.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
500                & 5               \\ \hline
360                & 3               \\ \hline
958                & 9               \\ \hline
\end{tabular}
\end{center}

\item Certo dia o professor de Johann Friederich Carl Gauss (aos 10 anos de 
idade) mandou que os alunos somassem os números de 1 a 100. Imediatamente 
Gauss achou a resposta – 5050 – aparentemente sem a soma de um em um. 
Supõe-se que já aí, Gauss, houvesse descoberto a fórmula de uma soma de uma 
progressão aritmética.

Agora você, com o auxílio dos conceitos de algoritmos e da linguagem 
\emph{Pascal} deve construir um programa que realize a soma de uma P.A. 
de $n$ termos, dado o primeiro termo $a1$ e o último termo $an$.
A impressão do resultado deve ser formatada com duas casas na direita.

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$n$ & $a_1$ & $a_n$   & $soma$               \\ \hline
100 & 1 & 100         & 5050.00                \\ \hline
10 & 1 & 10          & 55.00             \\ \hline
50 & 30 & 100         & 3250.00          \\ \hline
\end{tabular}
\end{center}

\item A sequência $A, B, C, \ldots$ determina uma Progressão Aritmética (P.A.). 
O termo médio ($B$) de uma P.A. é determinado pela média aritmética de seus 
termos, sucessor ($C$) e antecessor ($A$). Com base neste enunciado construa 
um programa em \emph{Pascal} que calcule e imprima o termo médio ($B$) 
através de $A$ e $C$, que devem ser lidos do teclado.

\[
B = \frac{A+B}{2}.
\]

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$A$ & $C$    & $B$               \\ \hline
1 & 3        & 2.00                \\ \hline
2 & 2        & 2.00             \\ \hline
100 & 500    & 300.00          \\ \hline
\end{tabular}
\end{center}

\item A sequência $A, B, C, \ldots$ determina uma Progressão Geométrica (P.G.), 
o termo médio ($B$) de uma P.G. é determinado pela média geométrica de seus 
termos, sucessor ($C$) e antecessor ($A$). Com base neste enunciado escreva 
um programa em \emph{Pascal} que calcule e imprima o termo médio ($B$) 
através de $A$, $C$, que devem ser lidos do teclado.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$A$ & $C$    & $B$               \\ \hline
1 & 3        & 1.73                \\ \hline
10 & 100        & 31.62             \\ \hline
90 & 80    & 84.85          \\ \hline
\end{tabular}
\end{center}

\item O produto de uma série de termos de uma Progressão Geométrica (P.G.) 
pode ser calculado pela fórmula abaixo:

\[
P = a_1^n \times q^{\frac{n(n-1)}{2}}.
\]

Agora, escreva um programa em \emph{Pascal} para determinar o produto dos 
$n$ primeiros termos de uma P.G de razão $q$. Seu programa deverá ler
$a_1, q, n$ do teclado e imprimir $P$.
(ATENÇÃO PARA O TIPO DE VARIÁVEL!)

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$a_1$ & $q$ & $n$   & $P$               \\ \hline
5 & 1 & 10         & 9765625.00                \\ \hline
1 & 1 & 10          & 1.00             \\ \hline
2 & 2 & 5         & 32768.00          \\ \hline
\end{tabular}
\end{center}

\item A soma dos termos de uma Progressão Geométrica (P.G.) finita pode ser 
calculada pela fórmula abaixo:

\[
S_n = \frac{a_1 (q^n - 1)}{q - 1}
\]

Agora, escreva um programa em \emph{Pascal} para determinar a soma dos $n$ 
termos de uma P.G de razão $q$, iniciando no termo $a_1$. Seu programa
deverá ler $a_1, q, n$ do teclado e imprimir $S_n$.

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$a_1$ & $q$ & $n$   & $S_n$               \\ \hline
2 & 3 & 6         & 728.00                \\ \hline
0 & 5 & 10          & 0.00             \\ \hline
150 & 30 & 2         & 4650.00          \\ \hline
\end{tabular}
\end{center}

\item Criar um programa em \emph{Pascal} para calcular e imprimir o valor do 
volume de uma lata de óleo, utilizando a fórmula:

\[
V = 3.14159 \times r^2 \times h,
\]

onde $V$ é o volume, $r$ é o raio e $h$ é a altura. Seu programa
deve ler $r, h$ do teclado e imprimir $V$.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
$r$ & $h$   & $V$               \\ \hline
5 & 100          & 7853.98                \\ \hline
25 & 25.5           & 69704.03             \\ \hline
10 & 50.9         & 15990.69          \\ \hline
\end{tabular}
\end{center}

\item Fazer um programa em \emph{Pascal} que efetue o cálculo do salário 
líquido de um professor. Os dados fornecidos serão: valor da hora aula, 
número de aulas dadas no mês e percentual de desconto do INSS.

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
valor hora aula & número de aulas & percentual INSS   & Salário bruto               \\ \hline
6.25 & 160 & 1.3         & 987.00                \\ \hline
20.5 & 240 & 1.7          & 4836.36             \\ \hline
13.9 & 200 & 6.48         & 2599.86          \\ \hline
\end{tabular}
\end{center}

\item Em épocas de pouco dinheiro, os comerciantes estão procurando aumentar 
suas vendas oferecendo desconto aos clientes. Escreva um programa em 
\emph{Pascal}  que possa entrar com o valor de um produto e imprima o novo 
valor tendo em vista que o desconto foi de 9\%. Além disso, imprima o valor 
do desconto.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
valor do produto (R\$) & novo valor (R\$) & valor do desconto (R\$) \\ \hline
100 & 91.00          & 9.00                \\ \hline
1500 & 1365.00       & 135.00             \\ \hline
60000 & 54600.00     & 5400.00          \\ \hline
\end{tabular}
\end{center}

\item Todo restaurante, embora por lei não possa obrigar o cliente a pagar, 
cobra 10\% de comissão para o garçom. Crie um programa em \emph{Pascal} que 
leia o valor gasto com despesas realizadas em um restaurante e imprima o i
valor da gorjeta e o valor total com a gorjeta.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo de entrada & Saída esperada \\ \hline
75                & 82.50              \\ \hline
125               & 137.50               \\ \hline
350.87            & 385.96               \\ \hline
\end{tabular}
\end{center}

\item Criar um programa em \emph{Pascal} que leia um valor de hora 
(hora:minutos), calcule e imprima o total de minutos se passaram desde o 
início do dia (0:00h). A entrada será dada por dois números separados
na mesma linha, o primeiro número representa as horas e o segundo os minutos.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
hora & minuto & total de minutos \\ \hline
1 & 0          & 60                \\ \hline
14 & 30       & 870             \\ \hline
23 & 55     & 1435          \\ \hline
\end{tabular}
\end{center}

\item Criar um programa em \emph{Pascal} que leia o valor de um depósito e o 
valor da taxa de juros. Calcular e imprimir o valor do rendimento do depósito 
e o valor total depois do rendimento.

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & \multicolumn{2}{|c|}{Saída esperada} \\ \hline
depósito & taxa de juros & rendimento & total \\ \hline
200 & 0.5 & 1.00   & 201.00            \\ \hline
1050 & 1 & 10.5    & 1060.5           \\ \hline
2300.38 & 0.06 & 1.38   & 2301.38          \\ \hline
\end{tabular}
\end{center}

\item Para vários tributos, a base de cálculo é o salário mínimo. Fazer um 
programa em \emph{Pascal} que leia o valor do salário mínimo e o valor do 
salário de uma pessoa. Calcular e imprimir quantos salários mínimos essa 
pessoa ganha.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
salário mínimo (R\$) & salário (R\$) & salário em salários mínimos (R\$) \\ \hline
450.89 & 2700.00 & 5.99            \\ \hline
1000.00& 1000.00 & 1.00           \\ \hline
897.50& 7800.00 & 8.69          \\ \hline
\end{tabular}
\end{center}

\item Criar um programa em \emph{Pascal} que efetue o cálculo da quantidade de 
litros de combustível gastos em uma viagem, sabendo-se que o carro faz 12 km 
com um litro. Deverão ser fornecidos o tempo gasto na viagem e a velocidade 
média.  $Distancia = Tempo \times Velocidade$.  $Litros = Distancia / 12$.
O algoritmo deverá apresentar os valores da Distância percorrida e a 
quantidade de Litros utilizados na viagem.

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{3}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
tempo gasto & velocidade média & distância percorrida & litros \\ \hline
60 & 100  & 6000.00 & 500.00             \\ \hline
1440 & 80 & 115200.00 & 9600.00           \\ \hline
5 & 90 & 450.00 & 37.50        \\ \hline
\end{tabular}
\end{center}

\item Um vendedor de uma loja de sapatos recebe como pagamento 20\% de comissão 
sobre as vendas do mês e R\$5.00 por cada par de sapatos vendidos. Faça
 um programa em \emph{Pascal} que, dado o 
total de vendas do mês e o número de sapatos vendidos, imprima quanto será o 
salário daquele mês do vendedor.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
total de vendas (R\$) & sapatos vendidos & salário (R\$) \\ \hline
50000.00 & 100 & 10500.00            \\ \hline
2000.00 & 30 & 550.00           \\ \hline
1000000.00 & 500 & 202500.00          \\ \hline
\end{tabular}
\end{center}

\item Você está endividado e quer administrar melhor sua vida financeira. 
Para isso, crie um programa em \emph{Pascal} que recebe o valor de uma dívida 
e o juros mensal, então calcule e imprima o valor da dívida no mês seguinte.

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & Saída esperada \\ \hline
valor da dívida (R\$) & juros/mês & dívida (R\$) \\ \hline
100.00 & 10  & 110.00            \\ \hline
1500.00 & 3 &  1545.00          \\ \hline
10000.00 & 0.5 & 10050.00          \\ \hline
\end{tabular}
\end{center}

\item Antes de o racionamento de energia ser decretado, quase ninguém falava 
em quilowatts; mas, agora, todos incorporaram essa palavra em seu vocabulário. 
Sabendo-se que 100 quilowatts de energia custa um sétimo do salário mínimo, 
fazer um programa em \emph{Pascal} que receba o valor do salário mínimo e a 
quantidade de quilowatts gasta por uma residência e imprima:
\begin{itemize}
\item o valor em reais de cada quilowatt;
\item o valor em reais a ser pago;
\end{itemize}

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{2}{|c|}{Exemplo de entrada} & \multicolumn{2}{|c|}{Saída esperada} \\ \hline
salário mínimo (R\$) & quilowatts & valor do quilowatt (R\$) & valor pago (R\$) \\ \hline
750.00 & 200 & 1.07 & 214.29           \\ \hline
935.00 & 150 & 1.34 & 200.36         \\ \hline
1200.00 & 250 & 1.71 & 428.57        \\ \hline
\end{tabular}
\end{center}

\item Indique qual o resultado das expressões abaixo, sendo: 

\[
  a=6; b=9.5; d=14; p=4; q=5; r=10; z=6.0 ; sim= TRUE.
\]

\begin {enumerate}
\item \verb|NOT sim AND (z DIV b + 1 = r)|
\item \verb|(x + y > z) AND sim OR (d \ge b)|
\item \verb|(x + y <> z) AND (sim OR (d \ge b))|
\end {enumerate}

\item Indique qual o resultado das expressões abaixo, sendo: 

\[
  a=5; b=3; d=7;  p=4; q=5; r=2; x=8; y=4; z=6; sim=TRUE.
\]

\begin{enumerate}
\item \verb|(z DIV a + b * a) - d DIV 2|
\item \verb|p / r mod q - q / 2|
\item \verb|(z DIV y + 1 = x) AND sim OR (y >= x)|
\end{enumerate}

\item Considere o seguinte programa incompleto em \emph{Pascal}:

\begin{lstlisting}
program tipos;
var 
     A: <tipo>;
     B: <tipo>;
     C: <tipo>;
     D: <tipo>;
     E: <tipo>;
begin
     A := 1 + 2 * 3;
     B := 1 + 2 * 3 / 7;
     C := 1 + 2 * 3 div 7;
     D := 3 div 3 * 4.0;
     E := A + B * C - D
end.
\end{lstlisting}

Você deve completar este programa indicando, para cada variável de $A$ até
$E$, qual é o tipo correto desta variável. Algumas delas podem ser tanto inteiras 
como reais, enquanto que algumas só podem ser de um tipo específico.
Para resolver este exercício você precisa estudar sobre os operadores
inteiros e reais e também sobre a ordem de precedência de operadores
que aparecem em uma expressão aritimética. Sua solução estará correta se seu 
programa compilar.

\item Escreva um programa em \emph{Pascal} que leia 
6 valores reais para as variáveis $A, B, C, D, E, F$ e 
imprima o valor de $X$ após o cálculo 
 da seguinte expressão aritmética:

\[ 
X = \frac{\frac{A + B}{C - D}E}{\frac{F}{AB} + E}
\]

Seu programa deve assumir que nunca haverá divisões por zero
para as variáveis dadas como entrada. Note que neste programa
a variável $X$ deve ser do tipo \emph{real}, enquanto que 
as outras variáveis podem ser tanto da família \emph{ordinal}
(\emph{integer, longint, etc}) como também podem ser do tipo
\emph{real}.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
1 2 3 4 5 6     & -1.8750000000000000E+000  \\ \hline
1 -1 1 -1 1 -1  & 0.0000000000000000E+000   \\ \hline
3 5 8 1 1 2     & 1.0084033613445378E+000   \\ \hline
\end{tabular}
\end{center}

\item Escreva em \emph{Pascal} as seguintes expressões
aritméticas usando o mínimo possível de parênteses.
Para resolver este exercício você precisa estudar sobre precedência
de operadores em uma expressão aritmética. Dica: para elevar um número
ao quadrado multiplique este número por ele mesmo ($x^2 = x * x$).

\begin{enumerate}
\item 
     \[ \frac{W^2}{Ax^2 + Bx +C} \]

\item 
     \[ \frac{\frac{P_1 + P_2}{Y - Z}R}{\frac{W}{AB} + R} \]
\end{enumerate}

\noindent
Observe que os compiladores não suportam o uso de subescritos, que são
utilizados na notação matemática. Então no lugar de $P_1$ e $P_2$, você
pode dar os nomes para as variáveis de $p1$ e $p2$ respectivamente.

\item Faça um programa em \emph{Pascal}
que some duas horas. A entrada deve ser feita lendo-se
dois inteiros por linha, em duas linhas, e a saída
deve ser feita no formato especificado no exemplo
abaixo:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
12 52           &                \\ 
7 13            & 12:52 + 7:13 = 20:05 \\ \hline
20 15           &                \\ 
1 45            & 20:15 + 1:45 = 22:00  \\ \hline
0 0             &                \\ 
8 35            & 0:0 + 8:35 = 8:35  \\ \hline
\end{tabular}
\end{center}

Você deve observar que o comando de impressão deve imprimir os espaços em branco e
os símbolos ``+'' e ``='' conforme o enunciado exige.

\item Dado um número inteiro que representa uma quantidade de segundos,
   determinar o seu valor equivalente em graus, minutos e segundos. Se
   a quantidade de segundos for insuficiente para dar um valor em graus,
   o valor em graus deve ser 0 (zero). A mesma observação vale em
   relação aos minutos e segundos. 

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
3600            & 1, 0, 0        \\ \hline
3500            & 0, 58, 20      \\ \hline
7220            & 2, 0, 20       \\ \hline
\end{tabular}
\end{center}

\item Fazer um programa em \emph{Pascal} que troque o conteúdo de duas 
variáveis. Exemplo:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
3 7             & 7 3            \\ \hline
-5 15           & 15 -5          \\ \hline
2 10            & 10 2           \\ \hline
\end{tabular}
\end{center}

\item (*) Desafio:
Fazer um programa em \emph{Pascal}
que troque o conteúdo de duas variáveis \emph{inteiras}
sem utilizar variáveis auxiliares. Pense em fazer contas
de adição e/ou subtração com os números. 


\item Indique qual o resultado das expressões abaixo, sendo: 

\[
  a=6; b=9.5; d=14; p=4; q=5; r=10; z=6.0 ; sim= TRUE.
\]

\begin {enumerate}
\item \verb|sim AND (q \ge p)|
\item \verb|(0 \le b) AND (z > a) OR (a = b)|
\item \verb|(0 \le b) AND ((z > a) OR (a = b))|
\item \verb|(0 \le b) OR ((z > a) AND (a = b))|
\end {enumerate}


\item Fazer uma função em \emph{Pascal} que receba como parâmetro 
   dois números inteiros não nulos e retorne TRUE se um for o contrário 
   do outro e FALSE em caso contrário. Isto é, se os parâmetros forem
   123 (cento e vinte e três) e 321 (trezentos e vinte e um), deve-se 
   retornar TRUE. Usar apenas operações sobre inteiros. 

\item Fazer uma  função  em \emph{Pascal}  
   que  receba como  parâmetro um  número
   inteiro  representando   um  número  binário  e   retorne  seu  valor
   equivalente em decimal. Por exemplo, se a entrada for 10001, a saída 
   deve ser 17. 

\item Fazer uma  função  em  \emph{Pascal}
   que  receba como  parâmetro um  número
   inteiro  e   retorne  TRUE  se  ele   for  primo  e   FALSE  em  caso
   contrário.  Use esta  função para  imprimir todos  os  números primos
   entre 0 e 1000. 

\item Implemente funções para seno e cosseno conforme definidos em 
   capítulos anteriores e use-as em uma terceira função que calcule a
   tangente. O programa principal deve imprimir os valores de $tg(x)$ 
   para um certo valor fornecido pelo usuário.

\item Faça uma função em \emph{Pascal} 
que some dois números representando horas. 
                  A entrada deve ser feita da seguinte maneira: \\
                        12 52 \\
                        7 13 \\
                  A sa\'{\i}da deve ser assim: \\
                  12:52 + 7:13 = 20:05
 
\item Faça uma função que receba como parâmetros seis variáveis 
DIA1, MES1 e ANO1, DIA2, MES2 e ANO2, todas do tipo integer. 
Considerando que cada trinca de dia, 
                  mês e ano representa uma data, a função deve retornar 
\textsf{true} se a primeira 
                  data for anterior à segunda e \textsf{false} 
caso contrário.



\end{enumerate}
\item Faça um programa em \emph{Pascal} que leia um número $n$ do teclado
e decida se ele é positivo ou negativo. Seu programa deve imprimir
a mensagem ``par'' ou ``impar'' conforme o caso. Exemplo:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5                & impar         \\ \hline
4                & par           \\ \hline
15               & impar         \\ \hline
\end{tabular}
\end{center}

\item Faça um programa em \emph{Pascal} que leia dois números $n, m$ do teclado
e decida se ele o primeiro é maior do que o segundo. Seu programa deve imprimir
a mensagem ``primeiro eh maior'' ou ``segundo eh maior ou igual'' conforme o caso. Exemplo:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5 2             & primeiro eh maior               \\ \hline
2 5             & segundo eh maior ou igual       \\ \hline
5 5             & segundo eh maior ou igual       \\ \hline
\end{tabular}
\end{center}

\item Faça um programa em \emph{Pascal} que leia três números $x, y, z$ 
do teclado e decida se $x \le y < z$. 
Seu programa deve imprimir a mensagem ``esta no intervalo'' 
ou ``nao esta no intervalo'' conforme o caso. Exemplo:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
3 5 8           & esta no intervalo \\ \hline
3 8 8           & nao esta no intervalo \\ \hline
4 12 5          & nao esta no intervalo \\ \hline
\end{tabular}
\end{center}

\item Faça um programa em \emph{Pascal} que leia três números $x, y, z$ 
do teclado e decida se $x > y$ ou se $y < z$. 
Seu programa deve imprimir a mensagem ``sim'' em caso afirmativo e  
``nao'' caso contrário. Exemplo:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
3 5 8                & sim                \\ \hline
3 8 8                & nao               \\ \hline
4 12 5               & nao               \\ \hline
\end{tabular}
\end{center}

\item Escreva um programa em \emph{Pascal} que leia
6 valores reais para as variáveis $A, B, C, D, E, F$ e
imprima o valor de $X$ após o cálculo
 da seguinte expressão aritmética:

     \[ X = \frac{\frac{A + B}{C - D}E}{\frac{F}{AB} + E} \]

Seu programa deve imprimir a mensagem ``divisao por zero''
caso o denominador seja zero. Caso isso não ocorra seu programa
irá abortar neste caso, o que não é correto.

Exemplos de entrada e saída:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
1 2 3 4 5 6     & -1.8750000000000000E+000  \\ \hline
0 0 0 0 0 0     & divisao por zero   \\ \hline
1 1 2 2 1 3     & divisao por zero   \\ \hline
\end{tabular}
\end{center}

\item Resolva o problema dos \emph{Vingadores}, que está nesta URL: \\
      \url{http://www.inf.ufpr.br/cursos/ci055/tad_conjunto/enunciado_tad.pdf}

\item Resolva o problema do \emph {Jogo da Vida}, que está nesta URL: \\
      \url{http://www.inf.ufpr.br/cursos/ci055/Util/vida/vida.html}

\item Fazendo uso das boas técnicas  de programação vistas durante o curso,
 faça um programa em  \emph{Pascal} que implemente  um \emph{jogo  da velha}:
 \begin{itemize}

  \item O jogo possui um tabuleiro composto de nove posições, na forma
  de uma matriz de  tamanho 3 por 3;  cada posição pode estar vazia ou
  pode ser ocupada pelo símbolo de um dos jogadores.

  \item Dois jogadores participam do jogo, sendo  que a cada um destes
  é associado um símbolo distinto, por exemplo: ``X'' e ``0''.

  \item A primeira jogada é efetuada pelo jogador X; em cada jogada um
  dos jogadores ocupa uma posição vazia  do tabuleiro; os jogadores se
  alternam a cada jogada.

  \item  Um dos jogadores vence  quando ocupa uma posição que completa
  uma seqüência   de  três símbolos   iguais em  uma  linha, coluna ou
  diagonal.

  \item O jogo termina empatado  quando todas as posições do tabuleiro
  foram ocupadas e não houve vencedor.
 \end{itemize}

\item Considere um jogo de Batalha Naval em que cada participante disporá seus 5 
barcos de 1, 2, 3, 4 e 5 células, respectivamente, no espaço de uma matriz 
de $N\times N (N \ge 100)$. 

Os barcos deverão estar ou na direção horizontal ou na vertical, deverão 
ser retos e não poderão se tocar. Não poderá haver barcos que passem pelas 
linhas e colunas marginais da matriz.

Escreva o programa principal para montar um jogo e fazer uma disputa entre 
dois adversários, especificando as chamadas às diferentes funções e 
procedimentos.

Escrever as funções e procedimentos necessários para o bom funcionamento do
seu programa principal acima.

Você deve documentar a lógica da solução de forma precisa. Em particular, 
descreva as estruturas de dados que você utilizar e a forma como elas serão 
usadas para resolver o problema.

%\item  implementar o caça-palavras
%
%\item  implementar o Sudoku
%
%\item implementar a TV da vovó
%
%\item implementar a espiral.

\end{enumerate}
\item Fazer um programa em \emph{Pascal} para
    ler uma massa de dados onde cada  linha da entrada contém um número  par.
    Para
    cada número lido,  calcular o seu sucessor par,  imprimindo-os dois a
    dois em  listagem de saída. A  última linha de dados  contém o número
    zero, o qual não deve ser processado e serve apenas para indicar o final
    da leitura dos dados. Exemplo:

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
12 6 26 86 0    & 12 14          \\ 
                & 6 8            \\ 
                & 26 28          \\ 
                & 86 88          \\ \hline
-2 -5 -1 0      & -2 0           \\
                & -5 -3          \\ 
                & -1 1           \\ \hline
1 2 3 4 5 0     & 1 3            \\
                & 2 4            \\
                & 3 5            \\
                & 4 6            \\
                & 5 7            \\ \hline
\end{tabular}
\end{center}

\item Fazer um programa em \emph{Pascal} para
    ler  uma massa de  dados contendo a  definição de várias  equações do
    segundo grau da forma $Ax^{2} + Bx + C = 0$. Cada linha de dados contém a
    definição de uma equação por meio dos valores de $A$, $B$ e $C$ do conjunto
    dos  números reais.  A última  linha  informada ao  sistema contém  3
    (três) valores  zero (exemplo  0.0 0.0 0.0).  Após a leitura  de cada
    linha o  programa deve tentar calcular  as duas raízes  da equação. A
    listagem de saída, em cada  linha, deverá conter
    os valores das duas raízes reais. Considere
    que o usuário entrará somente com valores $A$, $B$ e $C$ tais que a equação
    garantidamente tenha duas raízes reais. 

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
1.00 -1.00 -6.00 & -3.00 2.00 \\
1.00 0.00 -1.00  & -1.00 1.00 \\
1.00 0.00 0.00   & 0.00 0.00  \\ 
0.00 0.00 0.00   &            \\ \hline
\end{tabular}
\end{center}

\item Fazer um programa em \emph{Pascal} que receba dois números inteiros $N$ e
  $M$ como entrada e retorne como saída $N \ mod \ M$ (o resto da
  divisão inteira de $N$ por $M$) usando para isto apenas
  operações de subtração. O seu programa
  deve considerar que o usuário entra com $N$ sempre maior do que $M$.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
30 7            & 2              \\ \hline
3 2             & 1              \\ \hline
12 3            & 0              \\ \hline
\end{tabular}
\end{center}

\item Fazer um programa em \emph{Pascal} que leia um número $n > 0$ do
teclado e imprima a tabuada de $n$ de 1 até 10.

\begin{center}
\begin{tabular}{|l|l|} \hline
Exemplo Entrada & Saída esperada \\ \hline
5               & 5 x 1 = 5 \\
                & 5 x 2 = 10 \\
                & 5 x 3 = 15 \\
                & 5 x 4 = 20 \\
                & 5 x 5 = 25 \\
                & 5 x 6 = 30 \\
                & 5 x 7 = 35 \\
                & 5 x 8 = 40 \\
                & 5 x 9 = 45 \\
                & 5 x 10 = 50 \\ \hline
\end{tabular}
\end{center}
\item Fazer um programa em \emph{Pascal} que receba uma massa de dados
contendo o saldo bancário de alguns clientes de um banco
e imprima aqueles que são negativos. O último saldo, que não corresponde
a nenhum cliente (e portanto  não deve ser impresso), contém o valor
zero.

\begin{minipage}{5cm}
\begin{verbatim}
Entrada:
832.47
215.25
-1987.11
19.00
-45.38
0
\end{verbatim}
\end{minipage} \
\begin{minipage}{5cm}
\begin{verbatim}
Saída:
-1987.11
-45.38
\end{verbatim}
\end{minipage}


\item Dada uma matriz real A com $m$ linhas e $n$ colunas e um vetor real $V$ 
com $n$ elementos, determinar o produto  de $A$ por $V$. 

\item Um  vetor real $X$ com $n$  elementos é apresentado como  resultado 
de um sistema de  equações lineares $Ax=B$ cujos  coeficientes são representados
em uma  matriz real $A  (m \times n)$  e os lados  direitos das equações  em um
vetor real $B$ de $m$ elementos.  Verificar se o vetor $X$ é realmente solução
do sistema dado. 

\item Dizemos que uma  matriz inteira $A (n \times n)$ é 
uma matriz de permutação
se em cada linha e em cada  coluna houver $n-1$ elementos nulos e um único
elemento igual a 1.  Dada uma matriz inteira $A (n \times  n)$ verificar se 
$A$ é de permutação. Exemplos:

\begin{center}
\begin{tabular}{cccc}
0 & 1 & 0 & 0 \\ 
0 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 \\
\end{tabular}
\end{center}

é de permutação, enquanto que esta outra não é:

\begin{center}
\begin{tabular}{cccc}
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 2 \\
\end{tabular}
\end{center}

\item Dada uma matriz  $A (n \times m)$ 
imprimir o número de  linhas e o número de
colunas nulas da matriz. Exemplo: a matriz abaixo 
tem duas linhas e uma coluna nulas. 

\begin{center}
\begin{tabular}{cccc}
0 & 0 & 0 & 0 \\
1 & 0 & 2 & 2 \\
4 & 0 & 5 & 6 \\
0 & 0 & 0 & 0 \\
\end{tabular}
\end{center}



\item  Dizemos  que uma matriz  quadrada inteira é  um quadrado mágico  se a
soma dos elementos de cada linha,  a soma dos elementos de cada coluna e
a  soma dos  elementos das  diagonais principal  e secundária  são todos
iguais.  Exemplo:

\begin{center}
\begin{tabular}{ccc}
8 &  0 & 7 \\
4 &  5 & 6 \\
3 & 10 & 2 \\
\end{tabular}
\end{center}

é um quadrado mágico pois 
8+0+7 = 4+5+6 = 3+10+2 = 8+4+3 = 0+5+10 = 7+6+2 = 8+5+2 = 3+5+7 = 15.

\begin{enumerate}
\item Dada  uma matriz  quadrada  $A (n \times m)$,  
verificar  se $A$  é um  quadrado mágico. 
\item Informe quantas são e quais são as submatrizes não triviais
      (isto é, não pode ser a matriz constituída por unicamente um elemento, 
      uma linha e uma coluna) que definem quadrados mágicos. 
      Por exemplo, a matriz do exemplo acima
      tem 4 submatrizes de tamanho $2 \times 2$, duas submatrizes de 
      tamanho $2 \times 3$, etc, e uma única submatriz de dimensão
      $3 \times 3$;
\begin{itemize}
\item Armazene de alguma maneira as 
      informações necessárias sobre a localização precisa de cada uma das 
      submatrizes não triviais que definem quadrados mágicos;
\item Imprima a qualquer tempo algum quadrado mágico armazenado;
\item Dado uma dimensão qualquer, digamos $N$, imprima todas os 
      quadrados mágicos de dimensão $N$ contidos na matriz original.
\end{itemize}
\end{enumerate}


\item Implemente o quadrado ``quase magico''.  
Um quadrado quase magico é aquele em que as somas das linhas e a somas das
colunas resultam em um mesmo valor, mas a soma dos elementos das 
diagonais não.  O programa deve pedir a dimensão do
quadrado a ser impresso, que deve ser um número ímpar entre 1 e 99.



\item Um jogo  de palavras cruzadas pode ser representado  por uma matriz $A
(n \times  m)$ onde cada posição da  matriz corresonde a um  quadrado do jogo,
sendo  que 0  indica  um quadrado  em  branco e  -1  indica um  quadrado
preto.  Colocar as  numerações de  início de  palavras  horizontais e/ou
verticais  nos   quadrados  correspondentes  (substituindo   os  zeros),
considerando que uma palavra deve ter pelo menos duas letras. 

Exemplo: Dada a matriz:
\begin{center}
\begin{tabular}{cccccccc}
 0 & -1 &  0 & -1 & -1 &  0 & -1 &  0 \\
 0 &  0 &  0 &  0 & -1 &  0 &  0 &  0 \\
 0 &  0 & -1 & -1 &  0 &  0 & -1 &  0\\
-1 &  0 &  0 &  0 &  0 & -1 &  0 &  0\\
 0 &  0 & -1 &  0 &  0 &  0 & -1 & -1\\
\end{tabular}
\end{center}

A saída deveria ser:
\begin{center}
\begin{tabular}{cccccccc}
 1 & -1 &  2 & -1 & -1 &  3 & -1 &  4 \\
 5 &  6 &  0 &  0 & -1 &  7 &  0 &  0 \\
 8 &  0 & -1 & -1 &  9 &  0 & -1 &  0\\
-1 & 10 &  0 & 11 &  0 & -1 & 12 &  0\\
13 &  0 & -1 & 14 &  0 &  0 & -1 & -1\\
\end{tabular}
\end{center}

\item Uma matriz $D (8 \times 8)$ 
pode representar a posição atual de um jogo de damas, 
sendo que 0 indica uma casa vazia, 1 indica uma casa ocupada por uma peça branca
e -1 indica uma casa ocupada por uma peça preta. Supondo que as peças pretas
estão se movendo no sentido crescente das linhas da matriz $D$, determinar
as posições das peças pretas que:

\begin{itemize}
\item podem tomar peças brancas;
\item podem mover-se sem tomar peças brancas;
\item não podem se mover.
\end{itemize}

\item Deseja-se atualizar as contas correntes dos clientes de uma agência
bancária. É dado o cadastro de $N$ clientes contendo para cada cliente
o número de sua conta e seu saldo. O cadastro está ordenado pelo número 
da conta. Em seguida é dado o número de operações realizadas no dia, e, 
para cada operação, o número da conta, uma letra $C$ ou $D$ indicando se a
operação é de crédito ou débido, e o valor da operação. Emitir o cadastro
de clientes atualizado. Pode ser modelado como uma matriz $N \times 2$.


\item Reordenar a matriz do exercício anterior 
por ordem de saldo, do maior para o menor. 


\item Os elementos $M[i,j]$ de uma matriz $M (n \times n)$ 
representam os custos de
transporte da cidade $i$ para a cidade $j$. Dados $n$ itinerários lidos
do teclado, cada um
com $k$ cidades, calcular o custo total para cada itinerário. Exemplo:

\begin{verbatim}
4 1 2 3
5 2 1 400
2 1 3 8
7 1 2 5
\end{verbatim}

O custo do itinerário 1 4 2 4 4 3 2 1 é: 
M[1,4] + M[4,2] + M[2,4] + M[4,4] + M[4,3] + M[3,2] + M[2,1] =
3 + 1 + 400 + 5 + 2 + 1 + 5 = 417.


\item Considere $n$ cidades numeradas de 1 a $n$ que estão interligadas por
uma série de estradas de mão única. As ligações entre as cidades são 
representadas pelos elementos de uma matriz quadrada $L (n \times n)$ cujos
elementos L$[i,j]$ assumem o valor 0 ou 1 conforme exista ou não estrada
direta que saia da cidade $i$ e chegue na cidade $j$. Assim, os elementos
da $i$-ésima linha indicam as estradas que saem da cidade $i$ e os 
elementos da $j$-ésima coluna indicam as estradas que chegam à cidade $j$.
Por convenção, $L[i,i]=1$. A figura abaixo ilustra um exemplo para $n=4$.

\begin{center}
\begin{tabular}{ccccc}
  & A & B & C & D \\
A & 1 & 1 & 1 & 0 \\
B & 0 & 1 & 1 & 0 \\
C & 1 & 0 & 1 & 1 \\
D & 0 & 0 & 1 & 1 \\
\end{tabular}
\end{center}

Por exemplo, existe um caminho direto de $A$ para $B$ mas não de $A$ para $D$.

\begin{enumerate}
\item Dado $k$, determinar quantas estradas saem e quantas chegam à cidade $k$.
\item  A qual das cidades chega o maior número de estradas?
\item Dado $k$, verificar se todas as ligações diretas entre a cidade $k$ e 
   outras são de mão dupla;
\item  Relacionar as cidades que possuem saídas diretas para a cidade $k$;
\item Relacionar, se existirem:
  \begin{itemize}
   \item As cidades isoladas, isto é, as que não têm ligação com nenhuma outra;
   \item As cidades das quais não há saída, apesar de haver entrada;
   \item As cidades das quais há saída sem haver entrada;
  \end{itemize}
\item Dada uma sequência de m inteiros cujos valores estão entre 1 e $n$,
   verificar se é possível realizar o roteiro correspondente. No 
   exemplo dado, o roteiro representado pela sequência ($m=5$) 3 4 3 2 1
   é impossível;
\item Dados $k$ e $p$, determinar se é possível ir da cidade $k$ até a cidade 
   $p$
   pelas estradas existentes. Você consegue encontrar o menor caminho
   entre as duas cidades?
\item Dado $k$, determinar se é possível, partindo de $k$, passar por todas as
   outras cidades uma única vez e retornar a $k$.
\end{enumerate}

\item Uma matriz transposta $M^T$ é o resultado da troca de linhas por colunas em uma determinad
a matriz $M$.
Escreva um programa que leia duas matrizes ($A$ e $B$), e testa se $B = A +
 A^T$.

\item Fazer procedimentos que recebam três parâmetros:  uma matriz e dois
   inteiros representando as dimensões da matriz. Retornar: 
  \begin{enumerate} 
    \item a transposta de matriz; 
    \item a soma das duas matrizes;
    \item a multiplicação das duas matrizes.
  \end{enumerate} 

 \item Faça um programa que leia duas matrizes $A$
 e $B$ quaisquer e imprima a transposta de  $B$ se a transposta de $A$
 for igual a $B$.



\item Fazer uma função que receba  como parâmetros:  dois  vetores de
   reais    e   dois   inteiros    representando   as    dimensões   dos
   vetores. Retornar o produto escalar dos dois vetores (real). 
   Refazer a multiplicação de matrizes usando esta função. 


\item Faça um programa que, dadas $N$ datas em uma
matriz DATAS$_{N\times3}$, onde a primeira coluna corresponde ao dia, a segunda ao
mês e a terceira ao ano, coloque essas datas em ordem cronológica
crescente. Por exemplo:

\[
DATAS=\left( \begin{array}{ccc}
5&1&1996\\
25&6&1965\\
16&3&1951\\
15&1&1996\\
5&11&1965\\
\end{array}
\right)
DATAS=\left( \begin{array}{ccc}
16&3&1951\\
25&6&1965\\
5&11&1965\\
5&1&1996\\
15&1&1996\\
\end{array}
\right)
\]


\item Verifique se a matriz $A$ \'e sim\'etrica, isto \'e, se $A[i,j]=A[j,i], \forall i, j \le M$.
Fa\c ca uma fun\c c\~ao que retorne 1 em caso afirmativo, 0 caso contr\'ario.

\item Uma matriz $B$ é dita inversa da matriz $A$ quando $A \times B = I$, 
onde $I$ é a matriz identidade e $\times$ é a operação de multiplicação
de matrizes. A matriz identidade é a matriz quadrada onde os elementos da 
diagonal principal são 1 e os demais 0 ($I[i,j] = 1$ se $i=j$ e 
$I[i,j] = 0$ se $i \neq j$).  Escreva um programa em \emph{Pascal} que 
leia duas matrizes e testa se a segunda é a inversa da primeira.





\item Considere uma matriz $M$ de tamanho $N \times M$
utilizada para representar gotas de água (caractere $G$) em uma
janela. A cada unidade de tempo $T$, as gotas descem uma posição na
matriz, até que atinjam a base da janela e desapareçam. Considere que
a chuva parou no momento em que seu programa iniciou.

Exemplo:
\begin{small}
\begin{verbatim}
         Passo T=0           Passo T=1               Passo T=4
     -----------------   -----------------       ----------------- 
     |   G        G  |   |               |       |               |
     |       G       |   |   G        G  |       |               |
     |               |   |       G       |       |               |
     |     G   G     |   |               |  ...  |               |  ...
     |               |   |     G   G     |       |   G        G  |
     |               |   |               |       |       G       |
     |               |   |               |       |               |
     +++++++++++++++++   +++++++++++++++++       +++++++++++++++++
\end{verbatim}
\end{small}

Faça um programa em que:

\begin {enumerate}

\item 
Leia as coordenadas iniciais das gotas de água na matriz. O canto
superior esquerdo da matriz (desconsiderando as bordas) possui
coordenada $(1,1)$. A coordenada $(0,0)$ indica o término da
leitura. Coordenadas inválidas devem ser desconsideradas.

Exemplo de entrada para a matriz acima (em $T=0$):
\begin{small}
\begin{verbatim}
    1 4
    1 13
    4 6
    2 8
    100 98
    4 10
    0 0
\end{verbatim}
\end{small}
Note que a entrada $(100,98)$ deve ser descartada pois é inválida para
a matriz do exemplo.

\item 
Imprima, a cada unidade de tempo $T$, o conteúdo da matriz $M$,
atualizando a posição das gotas $G$ até que não reste nenhuma gota na
janela.
\end{enumerate}


\item Modifique seu programa da questão anterior de modo que as gotas que estão
inicialmente na primeira linha da janela desçam com o dobro da
velocidade das outras gotas. Ou seja, as gotas que iniciam na primeira
linha descem duas linhas na matriz a cada instante $T$. As gotas mais
rápidas podem encontrar gotas mais lentas pelo caminho, neste caso a
gota mais lenta desaparece ficando somente a mais rápida.

\item Modifique novamente o programa da questão anterior considerando que,
desta vez, a 
cada unidade de tempo $T$, $NG$ novas gotas são inseridas na matriz. Além
disso, as gotas descem na matriz até que atinjam a base da janela e desapareçam.
Inicialmente não há gotas na janela, pois a chuva começa quando $T=1$.

\vspace*{0.3cm}
Exemplo:
\begin{small}
\begin{verbatim}
         Passo T=1           Passo T=2             Passo T=1000
     -----------------   -----------------       ----------------- 
     |   G        G  |   |        G      |       |               |
     |       G       |   |   G        G  |       |  G            |
     |               |   |       G       |       |               |
     |     G   G     |   |               |  ...  |         G     |
     |               |   |     G   G     |       |   G        G  |
     |               |   |               |       |       G       |
     |               |   |  G            |       |               |
     +++++++++++++++++   +++++++++++++++++       +++++++++++++++++
\end{verbatim}
\end{small}

Faça um programa em  que:

\begin {enumerate}
\item 
Leia o número de linhas ($L$) e o número de colunas ($C$) da
matriz $M$, a quantidade de novas gotas a serem criadas a cada
iteração ($NG$), e o número de iterações ($TMAX$) do programa.

Exemplo de entrada para a matriz acima:
\begin{small}
\begin{verbatim}
    7 15 5 1000
\end{verbatim}
\end{small}

\item 
A cada unidade de tempo $T$, insira $NG$ novas gotas na matriz. A posição de 
uma nova gota é dada por um procedimento cujo protótipo é:
\begin{verbatim}
    Procedure coordenada_nova_gota(L,C:integer; VAR x,y:integer);
\end{verbatim}
Este procedimento 
recebe quatro parâmetros: os dois primeiros indicam o número de linhas e 
colunas da matriz $M$ ($L,C$). Os dois últimos retornam as coordenadas 
($x,y$) da nova gota na matriz.

\item
A cada unidade de tempo $T$, imprima o conteúdo da matriz $M$,
atualizando a posição das gotas $G$ seguindo os seguintes critérios:

        \begin{enumerate}
        \item
        Quando uma gota cai sobre outra, forme-se uma gota ``dupla'', ou seja, ela desce
        duas posições a cada instante $T$. Caso uma nova gota caia sobre uma gota
        ``dupla'', surge uma gota ``tripla'', que desce três posições a cada instante
        $T$, e assim por diante. 
        
        \item
        As gotas mais rápidas podem encontrar gotas mais lentas pelo caminho, neste caso
        a velocidade delas é somada.
        \end{enumerate}

\end{enumerate}



\item Considere o tipo PGM para imagens como definido na seção~\ref{pgm}.
Faça um programa que leia da entrada padrão 
(teclado) duas imagens no formato PGM: imagem original ($imgO$) e a imagem 
do padrão ($imgP$).
 
Em seguida, o programa deve procurar se a imagem $imgP$ está contida na 
imagem $imgO$ e imprimir na tela as coordenadas $(coluna,linha)$ do canto 
superior esquerdo de \textbf{cada ocorrência} da imagem $imgP$ encontrada na 
imagem $imgO$.

Observações:
\begin{itemize}
    \item A imagem $imgP$ pode aparecer mais de uma vez na imagem $imgO$;
    \item Na imagem $imgP$, pontos com o valor $-1$ devem ser ignorados, isto é, represent
am pontos transparentes da imagem e não devem ser comparados com a imagem $imgO$.
    \item Estruture seu código. A solução parcial ou a indicação de chamadas a funções não
 implementadas serão consideradas.
\end{itemize}

Exemplo:
\begin{itemize}
\vspace*{-2mm}      
    \item \textbf{Imagem original}:
    \begin{verbatim}
    P2
    11 10
    40
    40 5  5  5  5  5  5  5  5  40 0 
    5  20 20 5  5  5  5  5  5  5  5
    5  5  20 5  5  5  0  0  0  0  0
    5  5  20 20 5  5  20 20 0  0  5
    5  5  5  5  5  5  0  20 0  0  0
    5  5  5  5  5  5  0  20 20 0  5
    5  5  5  5  11 11 11 0  0  0  0
    5  5  5  5  20 20 11 5  5  5  5
    5  5  5  5  11 20 11 5  5  5  0
    40 5  5  5  11 20 20 5  5  40 5
    \end{verbatim}

\vspace*{-4mm}      
    \item \textbf{Imagem do padrão}:
    \begin{verbatim}
    P2
    3 3
    20
    20 20 -1
    -1 20 -1
    -1 20 20
    \end{verbatim}
    
\vspace*{-4mm}      
    \item \textbf{Resultado do Programa}:
    \begin{verbatim}
    2 2
    7 4
    5 8   
    \end{verbatim}    
\end{itemize}

\item Modifique o programa anterior de forma que, ao invés de imprimir as 
coordenadas, seja impressa uma nova imagem, que consiste de uma cópia da 
imagem original $imgO$ na qual as ocorrências da imagem $imgP$ estejam 
circunscritas por uma borda de um ponto de largura, com o valor máximo da 
imagem $imgO$ (3ª linha do arquivo PGM). Você não precisa se preocupar com 
possíveis sobreposições das bordas.

Exemplo da nova saída para a entrada original:
\begin{itemize}
\vspace*{-2mm}      
    \item \textbf{Imagem resultante}:
    \begin{verbatim}
    P2
    11 10
    40
    40 40 40 40 40 5  5  5  5  40 0
    40 20 20 5  40 5  5  5  5  5  5
    40 5  20 5  40 40 40 40 40 40 0
    40 5  20 20 40 40 20 20 0  40 5
    40 40 40 40 40 40 0  20 0  40 0
    5  5  5  5  5  40 0  20 20 40 5
    5  5  5  40 40 40 40 40 40 40 0
    5  5  5  40 20 20 11 40 5  5  5
    5  5  5  40 11 20 11 40 5  5  0
    40 5  5  40 11 20 20 40 5  40 5
    \end{verbatim}
\end{itemize}

\item Uma matriz é chamada de \textit{esparsa} quando 
possui uma grande quantidade de elementos que valem zero. Por exemplo,
a matriz de ordem $5 \times 4$ seguinte é esparsa, pois contém somente
4 elementos não nulos.

\begin{center}
\begin{tabular}{c|c|c|c|c|} 
\multicolumn{1}{c}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{
3} & \multicolumn{1}{c}{4} \\ \cline{2-5}
1 & 0  & 17 & 0   & 0 \\ \cline{2-5}
2 & 0  & 0  & 0   & 0 \\ \cline{2-5}
3 & 13 & 0  & -12 & 0 \\ \cline{2-5}
4 & 0  & 0  & 25  & 0 \\ \cline{2-5}
5 & 0  & 0  & 0   & 0 \\ \cline{2-5}
\end{tabular}
\end{center}

Obviamente, a representação computacional padrão para matrizes é
ineficiente em termos de memória, pois gasta-se um espaço inútil para
se representar muitos elementos nulos. 

Nesta questão, vamos usar uma representação alternativa que vai permitir
uma boa economia de memória. 

A proposta é representar somente os elementos não nulos. Para isto usaremos
três vetores, dois deles ($L$ e $C$) 
para guardar as coordenadas dos elementos não nulos
e o terceiro (D) para guardar os valores dos elementos daquelas coordenadas. 
Também
usaremos três variáveis para representar o número de linhas e colunas
da matriz completa e o número de elementos não nulos da matriz.

Considere as seguintes definições de tipos:
\begin{lstlisting}
CONST
     MAX = 6;      (* um valor bem menor que 5 x 4, dimensao da matriz *) 
TYPE 
     vetor_coordenadas = array [1..MAX] of integer;  (* coordenadas    *)
     vetor_elementos   = array [1..MAX] of real;     (* dados          *)
VAR
     L, C: vetor_coordenadas; (* L: linhas, C: colunas                 *)
     D: vetor_elementos;      (* D: dados                              *)
     N_lin, N_col: integer;   (* para armazenar as dimensoes da matriz *)
     N_elementos: integer     (* numero de elementos nao nulos         *)
\end{lstlisting}


\newtheorem{definicao}{Definição}

\begin{definicao}
\label{def1}
Um elemento M[i,j] da matriz completa pode ser 
obtido da representação compactada: 

\begin{itemize}
\item se existe um k tal que L[k] = i e C[k] = j, então M[i,j] = D[k];
\item caso contrário, M[i,j] = 0.
\end{itemize} 
\end{definicao}

A matriz do exemplo anterior pode então ser assim representada:

\begin{verbatim}
N_elementos:= 4; N_lin:= 5; N_col:= 4;
\end{verbatim}

\begin{center}
\begin{tabular}{c|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|} 
\multicolumn{1}{c}{} & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{
3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6}\\ \cline{2-7}
L & 1  & 3  & 3   & 4 & & \\ \cline{2-7}
\end{tabular}


\begin{tabular}{c|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|} 
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} 
& \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\\ \cline{2-7}
C & 2  & 1  & 3   & 3 & & \\ \cline{2-7}
\end{tabular}

\begin{tabular}{c|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|p{.6cm}|} 
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} 
& \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{}\\ \cline{2-7}
D & 17  & 13  & -12   & 25 & & \\ \cline{2-7}
\end{tabular}
\end{center}

\begin {enumerate}


\item Fazer um procedimento que leia da entrada padrão: 
\begin{itemize}
\item dois inteiros, representando as dimensões da matriz (linha, coluna);
\item trincas de elementos l, c, d, onde l e c são inteiros e d é real,
representando respectivamente a linha, a coluna
e o valor de um elemento não nulo da matriz. A leitura termina quando for
lido uma trinca 0, 0, 0. Para cada trinca, devem ser criados os três
vetores que representam a matriz conforme descrito acima. Veja o exemplo
de entrada de dados, abaixo.
\end{itemize}

Exemplo para a entrada de dados:

\begin{verbatim}
5 4
1 2 17
3 1 13
3 3 -12
4 3 25
0 0 0 
\end{verbatim}


\item Fazer uma função que, dada uma coordenada (l, c), respectivamente
para uma linha e coluna,
retorne o valor de elemento M[l,c], conforme a definição \ref{def1}.

\item Fazer um procedimento que,  dadas duas matrizes no formato compactado
descrito acima, obtenha uma terceira matriz compactada que é a soma
das duas primeiras. 

\item Fazer um procedimento que, dada uma matriz no formato compactado,
imprima na tela uma matriz no formato padrão, contendo os zeros.

%\item Fazer uma função que testa se uma entrada dada conforme o item 1
%acima corresponde de fato a uma matriz esparsa. Considere que a matriz
%é esparsa se no máximo 15\% dos elementos forem não nulos.
\end{enumerate}




\item Declare uma matriz $M \times N$ de caracteres do
  tipo \textsf{char}.  Implemente quatro funções que, dados como
  parâmetros a matriz, uma palavra do tipo \textsf{string} e um par de
  coordenadas na matriz, isto é, dois inteiros representando uma linha e
  uma coluna,  descubram se,  na matriz, a  palavra ocorre  iniciando na
  posição indicada pelas coordenadas. 
A primeira função procura na horizontal, da esquerda para direita;
a segunda função procura na horizontal, da direita para esquerda;
a terceira função procura na vertical, da cima para baixo;
a quarta função procura na vertical, da baixo para cima.




\item Os incas construiam pirâmides de base quadrada em
que a única forma de se atingir o topo era seguir em espiral pela
borda, que acabava formando uma escada em espiral.  Escreva um
programa que leia do teclado uma matriz quadrada $N \times N$ de
números inteiros e verifica se a matriz é inca; ou seja, se partindo
do canto superior esquerdo da matriz, no sentido horário, em espiral,
a posição seguinte na ordem é o inteiro consecutivo da posição
anterior.  Por exemplo, as matrizes abaixo são incas:

\begin{verbatim}
   1   2   3   4        1   2   3   4   5
  12  13  14   5       16  17  18  19   6        
  11  16  15   6       15  24  25  20   7
  10   9   8   7       14  23  22  21   8
                       13  12  11  10   9
\end{verbatim}

O programa deve ler do teclado a dimensão da matriz 
(um inteiro $N$, $1 \leq N \leq 100$) e em cada uma das próximas $N$ linhas, 
os inteiros correspondentes às  entradas da matriz naquela linha.  
A saída do programa deve ser
``A matriz eh inca'' ou ``A matriz nao eh inca''.

\item Escreva um programa em \emph{Pascal} que leia do teclado uma matriz A 
($N \times M$)
de inteiros e imprima uma segunda matriz $B$ de mesma dimensões em que
cada elemento $B[i,j]$ seja constituído pela soma de todos os 8 elementos
vizinhos do elemento $A[i,j]$, excetuando-se o próprio $A[i,j]$.


\item Nesta questão você terá que providenciar ligações par-a-par 
entre diversos pontos distribuídos ao longo de uma rota qualquer.
A entrada de dados consiste de um conjunto de pares $(x,y), 1\leq x,y \leq
MAX$, sendo
que o último par a ser lido é o (0,0), que não deve ser processado.

Para cada par $(x,y)$ dado como entrada, você deve providenciar uma
conexão física entre eles. 
As linhas de uma matriz podem representar a ``altura'' das
linhas de conexão, enquanto que as colunas da matriz podem representar
os pontos $(x,y)$ sendo conectados. Um símbolo de ``\verb#+#'' pode ser 
usado para se representar alteração na direção de uma conexão. 
O símbolo ``\verb#|#'' pode ser usado para representar um trecho de 
conexão na vertical. Finalmente o símbolo ``\verb#-#'' pode ser usado
para se representar um trecho de conexão na direção horizontal.
Quando um cruzamento de linhas for inevitável, deve-se usar o
símbolo ``\verb#x#'' para representá-lo. Considere que não existem trechos 
de conexões na diagonal.

Por exemplo, suponha que a entrada é dada pelos seguintes pares:

\begin{verbatim}
3 5
2 9
0 0
\end{verbatim}

Uma possível saída para seu programa seria a impressão da seguinte
matriz:

\begin{verbatim}
4
3         
2  +-------------+
1  | +---+       |
 1 2 3 4 5 6 7 8 9
\end{verbatim}

Outra possível matriz solução para este problema seria esta:
\begin{verbatim}
4
3         
2    +---+  
1  +-x---x-------+
 1 2 3 4 5 6 7 8 9
\end{verbatim}

Note que nesta última versão foi preciso inserir dois cruzamentos.

Ainda como exemplo, se o par (6,8) também fosse dado como entrada no 
exemplo anterior, a saída do programa poderia ser assim exibida:

\begin{verbatim}
4
3          +---+ 
2  +-------x---x-+
1  | +---+ |   | |
 1 2 3 4 5 6 7 8 9
\end{verbatim}

Você deve implementar um programa em \emph{Pascal} que seja
capaz de ler uma sequência de pares terminada em $(0,0)$ (como no
exemplo acima) e que imprima o desenho das conexões como saída,
também conforme o diagrama acima. 


\item 
Modifique o programa anterior com o objetivo de minizar o número de cruzamentos
da matriz gerada como solução do problema anterior. Assim,
a matriz ideal para ser dada como resposta do último exemplo
seria a seguinte:

\begin{verbatim}
4
3           
2  +-------------+
1  | +---+ +---+ |
 1 2 3 4 5 6 7 8 9
\end{verbatim}

\item Considere o seguinte programa:

\begin{lstlisting}
program prova_final;

CONST MAX=100;
TYPE matriz = array [1..MAX,1..MAX] of integer;
VAR n_lin, n_col: integer; (* dimensoes da matriz *)
    m: matriz;             (* matriz *)

(* espaco reservado para os procedimentos *)

begin
   read (n_lin, n_col);
   le_matriz (m, n_lin, n_col);
   acha_maior_sequencia (m, n_lin, n_col, l_ini, c_ini, l_fim, c_fim);
   writeln ('A maior sequencia de numeros repetidos na matriz ');
   writeln ('inicia na coordenada ', l_ini, c_ini);
   writeln (' e termina na coordenada ', l_fim, c_fim);
end.
\end{lstlisting}


Implemente os procedimentos indicados para 
que o programa leia uma matriz de inteiros e imprima as coordenadas
de início e término da maior sequência de números repetidos da matriz.
Esta sequência pode estar tanto nas linhas quanto nas colunas. No caso
de existir mais de uma sequência repetida de mesmo tamanho, você pode
imprimir as coordenadas de qualquer uma delas, desde que imprima as de uma só.

\begin{minipage}{7cm}
\begin{verbatim}
Exemplo 1:
Entrada:      Saída
4 3           1 2 
1 2 3         3 2
2 2 1
3 2 5
\end{verbatim}
\end{minipage} \  
\begin{minipage}{7cm}
\begin{verbatim}
Exemplo 2:
Entrada:      Saída
4 5           2 2
1 2 3 1 2     2 4
1 2 2 2 3
2 3 4 5 6
8 7 6 4 2
\end{verbatim}
\end{minipage}



\item Faça um programa para:
\begin{itemize}
    \item ler uma sequência de polinômios 
    $P_i(x)=a_{i_0} + a_{i_1}x + a_{i_2}x^2 + ... + a_{i_n}x^n, i=1,2,...,k$; 

    \item A leitura deve considerar que cada linha de entrada    
    contém um polinômio $P_i$. A primeira informação é o seu 
    respectivo grau ($n_i$). As outras informações são os
    $n_i$ coeficientes ($a_{i_0}, a_{i_1}, ..., a_{i_n}$);
    
    Exemplo:
    
    $P(x) = 8.1 -3.4x + x^2  \Longrightarrow $ \verb|2  8.1  -3.4  1.0|
    
    \item A sequência de polinômios se encerra quando for fornecido um 
    polinômio de grau zero; 
    
    \item Após a leitura de todos os polinômios, o programa deve ler uma 
    sequência de números reais $x$. Para cada número real lido, o programa 
    deve imprimir o resultado de $P_i(x)$, para todos os polinômios lidos 
    anteriormente ($i=1,2,...,k$);
    
    \item A sequência de números reais se encerra quando for lido o número 
    $0.0$, para o qual não se deve calcular os valores de $P_i(x)$.
\end{itemize}    
    
Exemplo:
\begin{verbatim}
Entrada:
2  -1.0 0.0 1.0
3  1.0  2.0  0.0  -1.0
0
4.5
1.0
0.0

Saída:
P_1(2.0) = 3.0
P_2(2.0) = -3.0
P_1(1.0) = 0.0
P_2(1.0) = 2.0
\end{verbatim}


\item Faça um programa para:

\begin{itemize}
\item ler um inteiro $N$ e uma matriz quadrada de ordem $N$ contendo apenas
      0's e 1's.
\item encontrar a maior submatriz quadrada da matriz de entrada
      que contém apenas 1's.
\item imprimir as coordenadas dos cantos superior esquerdo e
      inferior direito da submatriz encontrada no item anterior. Havendo mais 
      de uma submatriz máxima, imprimir as coordenadas de qualquer uma delas.
\end{itemize}


\noindent Exemplo: Considere a seguinte matriz quadrada de 
ordem 6:

\vspace*{\baselineskip}

\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|}
\multicolumn{1}{c}{}  & \multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} \\ \cline{2-7}
1 & 0 & 1 & 0 & 1 & 1 & 1 \\ \cline{2-7}
2 & 0 & 1 & 1 & 1 & 1 & 0 \\ \cline{2-7}
3 & 0 & 1 & 1 & 1 & 0 & 1 \\ \cline{2-7}
4 & 1 & 1 & 1 & 1 & 0 & 1 \\ \cline{2-7}
5 & 0 & 0 & 1 & 0 & 1 & 0 \\ \cline{2-7}
6 & 0 & 1 & 0 & 1 & 0 & 1 \\ \cline{2-7}
\end{tabular}
\end{center}

\vspace*{\baselineskip}

A título de ilustração, esta matriz tem:

\begin{itemize}
\item 22 submatrizes quadradas de ordem 1 que contém apenas 1's;
\item 5 submatrizes quadradas de ordem 2 que contém apenas 1's. Por exemplo, 
      para duas delas: uma é dada pelas coordenadas (1,4) e (2,5) e outra 
      pelas coordenadas (2,2) e (3,3);
\item 1 submatriz quadrada de ordem 3 que contém apenas 1's, as coordenadas são (2,2) e (4,4).
\end{itemize}

Como a maior submatriz quadrada que contém apenas 1's é a de ordem 3,
então a saída do programa deve imprimir, para este exemplo, as coordenadas
(2,2) e (4,4).



\item Escreva um programa que, dado um tabuleiro e uma lista de sub-partes 
retangulares do tabuleiro, retorna o número de posições que não pertencem 
a nenhuma sub-parte. Quando uma posição não pertence a nenhuma sub-parte
dizemos que ela está \emph{perdida}.

\vspace*{\baselineskip}

\begin{center}
\textbf{Entrada}
\end{center}


A entrada consiste de uma série de conjuntos de teste. 

Um conjunto de teste começa com uma linha com três números $W$, $H$ e $N$, 
indicando, respectivamente, a largura e a altura do tabuleiro 
e o número de sub-partes deste. 
%
Estes valores satisfazem as seguintes restrições: 
$1 \leq W$, $H \leq 500$ e $0 \leq N \leq 99$. 

Seguem $N$ linhas, compostas de quatro inteiros 
$X_1$, $Y_1$, $X_2$ e $Y_2$, 
tais que $(X_1, Y_1)$ e $(X_2, Y_2)$ 
são as posições de dois cantos opostos de uma sub-parte. 
%
Estes valores satisfazem as seguintes restrições: 
$1 \leq X_1$, $X_2 \leq W$ e $1 \leq Y_1$, $Y_2 \leq H$. 

O fim da entrada acontece quando $W=H=N=0$. 
Esta última entrada não deve ser considerada como um conjunto de teste.

\begin{center}
\textbf{Saída}
\end{center}

O programa deve imprimir um resultado por linha, seguindo o formato 
descrito no exemplo de saída.

\begin{verbatim}
Exemplo

Entrada:
1 1 1
1 1 1 1                {fim do primeiro conjunto de testes}
2 2 2
1 1 1 2
1 1 2 1                {fim do segundo conjunto de testes }
493 182 3
349 148 363 146
241 123 443 147
303 124 293 17         {fim do terceiro conjunto de testes}
0 0 0                  {fim do conjunto de testes}

Saída
Não há posições perdidas. 
Existe uma posição perdida.
Existem 83470 posições perdidas.
\end{verbatim}


\end{enumerate}
\item Fazer um programa em \emph{Pascal} que leia do teclado dois números inteiros positivos e que imprima na saída um único número inteiro
que é a soma dos dois primeiros. Entretanto, seu programa não pode utilizar o operador de soma (+) da linguagem \emph{Pascal} para somar os dois inteiros lidos em uma única operação. Outrossim, o programa deve implementar a soma dos números dígito a dígito, iniciando pelo menos significativo até o mais significativo, considerando o ``vai um'', conforme costumamos
fazer manualmente desde o ensino fundamental.

\begin{verbatim}
Exemplo 1                    Exemplo 2
 11   ("vai um")              1111   ("vai um")
40912 (primeiro número)        52986 (primeiro número)
 1093 (segundo número)       1058021 (segundo número)
-----                        -------
42005 (soma)                 1111007 (soma)
\end{verbatim}

\item Um agricultor possui 1 (uma) espiga de milho. Cada espiga tem 150 grãos,
e cada grão pesa 1g (um grama). Escreva um programa em \emph{Pascal} para
determinar quantos anos serão necessários para que o agricultor colha
mais de cem toneladas de milho (1T = 1000Kg, 1Kg = 1000g), sendo que:

\begin{itemize}
\item A cada ano ele planta todos os grãos da colheita anterior
\item Há uma única colheita por ano
\item 10\% (dez por cento) dos grãos não germina (morre sem produzir)
\item Cada grão que germina produz duas espigas de milho
\end{itemize}

Assuma que a quantidade de terra disponível é sempre suficiente para o
plantio.

\item Modifique a questão anterior acrescentando na simulação os seguintes fatos:

\begin{itemize}
\item  Há 8 (oito) CASAIS de pombas (16 pombas) que moram na propriedade
       do agricultor.
\item Cada pomba come 30 grãos por dia, durante os 30 dias do ano em que
as espigas estão formadas antes da colheita;
\item A cada ano, cada casal gera 2 novos casais (4 pombas), que se
alimentarão e reproduzirão no ano seguinte;
\item Uma pomba vive tres anos;
\end{itemize}

Ao final do programa, imprima também o número de pombas que vivem na
propriedade quando o agricultor colher mais de 100T de milho

\item Considere um número inteiro com 9 dígitos. Suponha que o  último dígito seja o ``dígito verificador''
 do número formado pelos 8 primeiros. Faça um programa em \emph{Pascal} que leia uma massa de dados terminada por 0 (zero) e que
imprima os números que não são bem formados, isto é, aqueles que não satisfazem o dígito
verificador. Implemente o seguinte algoritmo para gerar o dígito verificador:

Conforme o esquema abaixo, cada dígito do número, começando da direita para a esquerda
(menos significativo para o mais significativo) é multiplicado, na ordem, por 2, depois 1,
depois 2, depois 1 e assim sucessivamente.

Número exemplo: 261533-4

\begin{center}
\begin{small}
\begin{verbatim}

  +---+---+---+---+---+---+   +---+
  | 2 | 6 | 1 | 5 | 3 | 3 | - | 4 |
  +---+---+---+---+---+---+   +---+
    |   |   |   |   |   |
   x1  x2  x1  x2  x1  x2
    |   |   |   |   |   |
   =2 =12  =1 =10  =3  =6
    +---+---+---+---+---+-> = (16 / 10) = 1, resto 6 => DV = (10 - 6) = 4 

\end{verbatim}
\end{small}
\end{center}

Ao invés de ser feita a somatória das multiplicações, será feita a somatória dos dígitos das multiplicações
(se uma multiplicação der 12, por exemplo, será somado 1 + 2 = 3).

A somatória será dividida por 10 e se o resto (módulo 10) for diferente de zero, o dígito será 10 menos este valor.

\item 
Escreva um programa \emph{Pascal} que leia dois valores inteiros positivos A e B.
Se A for igual a B, devem ser lidos novos valores até que sejam informados
valores distintos.  Se A for menor que B, o programa deve calcular e
escrever a soma dos números ímpares existentes entre A(inclusive) e
B(inclusive).  Se A for maior que B, o programa deve calcular e escrever a
média aritmética dos múltiplos de 3 existentes entre A(inclusive) e
B(inclusive).


\item 
Faça um  programa em \emph{Pascal} que dado
 uma sequência de números inteiros  terminada por zero (0), determinar
 quantos segmentos    de  números iguais consecutivos     compõem essa
 sequência.

Ex.: A sequência 2,2,3,3,5,1,1,1 é  formada por 4 segmentos de números
iguais.


\item Faça um programa em \emph{Pascal} que imprima a seguinte
sequência de números: 1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 
7, 7, 7, 7, 7, 8, 8, 8, 8, 8, \ldots

\item Faça um programa em \emph{Pascal} que 
receba como entrada um dado 
inteiro $N$ e o imprima como um produto de primos. Exemplos:
$45 = 3 \times 3 \times 5$. $56 = 2 \times 2 \times 2 \times 7$.

\item Faça um programa em \emph{Pascal} que, dado
um número inteiro $N$, escreva o maior divisor de $N$ que é uma potência
de um dos números primos fatorados. Ex:

\hspace{2cm} $N=45 = 3^2.5^1 $ escreve $9=3^2$

\hspace{2cm} $N=145 = 5^2.7^1 $ escreve $25=5^2$

\hspace{2cm} $N=5616 = 2^4.3^3.13 $ escreve $27=3^3$

\end{enumerate}
\item Latitude e longitude s\~ao especificados em graus, ($^{o}$), minutos ('),
segundos (''), e dire\c c\~ao (N, S, L, O). Por exemplo, a cidade A fica
na latitude 22$^{o}$17'34''N e longitude 53$^{o}$41'9''O.

Defina um tipo em \emph{Pascal} 
cujo nome seja {\bf localizacao}, e que seja constituido
de {\em longitude} e {\em latitude}, ambas do tipo {\bf coordenadas}. Para
isto voce ter\'a que definir o tipo {\bf coordenadas} como sendo constituido
de {\em grau}, {\em minutos}, {\em segundos} e {\em direcao}.

\item Declare um vetor onde cada elemento \'e um registro com os campos: nome, DDD, telefone, CPF, Idade.
\item Considerando o vetor n\~ao ordenado, encontrar e imprimir o nome do cliente mais jovem. Fa\c ca um 
procedimento para isto
\item Ordenar por ordem de nome. Fa\c ca um procedimento para isto.
\item Dado um CPF, localizar se o nome est\'a no vetor e imprimir todos os dados. Fa\c ca um procedimento para
isto.
\item Fa\c ca um procedimento que receba por valor par\^ametros para nome, DDD, telefone, CPF, Idade 
e o insira no vetor (que j\'a est\'a ordenado) em ordem alfab\'etica. N\~ao vale usar um vetor auxiliar.
Retornar por refer\^encia o vetor alterado

\item Considere o arquivo de uma empresa (chamado de ``func.dat'' -- um arquivo
de registros) contendo
para cada funcionário seu número, seu nível salarial e seu departamento.
Como a administração desta empresa é feita a nível departamental é
importante que no arquivo os funcionários de cada um dos departamentos
estejam relacionados entre si e ordenados sequencialmente pelo seu número.
Como são frequentes as mudanças interdepartamentais no quadro de
funcionários, não é conveniente reestruturar o arquivo a cada uma destas
mudanças.  Desta maneira, o arquivo poderia ser organizado da seguinte
forma:

\begin{verbatim}
linha numFunc nivel departamento proximo
0     123     7     1            5
1     8765    12    1            -1
2     9210    4     2            -1
3     2628    4     3            6
4     5571    8     2            -1
5     652     1     1            9
6     7943    1     3            -1
7     671     5     3            12
8     1956    11    2            11
9     1398    6     1            10
10    3356    3     1            1
11    4050    2     2            4
12    2468    9     3            3
\end{verbatim}




Em um segundo arquivo (chamado ``depto.dat'' -- um arquivo de registros)
temos as seguintes informações:

\begin{verbatim}
codDepto nomeDepto      inicio
1        vendas         0
2        contabilidade  8
3        estoque        7
4        entrega        2
\end{verbatim}

Assim, o primeiro funcionário do departamento de vendas é o registro 0 do
arquivo de funcionários e os demais funcionários do mesmo departamento são
obtidos seguindo o campo {\tt proximo}.  Ou seja, os funcionários do
departamento de vendas são os funcionários nos registros: 0, 5, 9, 10 e 1.
Os funcionários do departamento de contabilidade são os funcionários nos
registros: 8, 11 e 4.

Escreva um programa em \emph{Pascal} que realize as seguintes operações:
\begin{itemize}
\item admissão de novo funcionário
\item demissão de funcionário
\item mudança de departamento por um funcionário
\end{itemize} 

Para estas operações devem ser lidas as informações:
\begin{itemize}
\item código do tipo da operação: 0 para fim, 1 para admissão, 2 para
  demissão e 3 para mudança de departamento
\item número do funcionário
\item nível salarial (somente no caso de admissão)
\item número do departamento ao qual o funcionário passa a pertencer (no
  caso de admissão e mudança)
\item número do departamento do qual o funcionário foi desligado (no caso
  de demissão e mudança)
\end{itemize}



O programa deve escrever as seguintes informações:
\begin{itemize}
\item os valores iniciais lidos dos arquivos
\item para cada operação: o tipo da operação realizada, os dados da
operação e a forma final dos dados (de funcionários e departamentos)
\end{itemize}

No final do programa novos arquivos ``func.dat'' e ``depto.dat'' são
gerados com os dados atualizados.

Detalhamento:
\begin{itemize}
\item a quantidade máxima de funcionários é 1000
\item a quantidade máxima de departamentos é 20
\item se a quantidade máxima for ultrapassada o programa deve dar uma
mensagem de erro
\item se for requisitada a remoção ou mudança de um funcionário não
  existente no departamento especificado o programa deve dar uma mensagem
  de erro.
\item quando for requisitada a inserção de um novo funcionário é preciso
  verificar se um funcionário com o mesmo número já existe.
\item se o código de operação for inválido o programa deve continuar lendo
um novo código até que ele seja 0 (zero), 1 (um), 2 (dois) ou 3 (três).
\end{itemize}


\item Uma empreiteira tem contratos para construir diversos tipos de casa: moderno,
fazenda, colonial, etc.   A quantidade de material empregada para cada
tipo de casa está armazenada em um arquivo chamado  ``material.dat''.
Este é um {\em arquivo de registros} contendo: o tipo de casa e as respectivas
quantidades de cada material necessárias para sua
construção. Existem no máximo 50 tipos de casas e 100 tipos distintos de
materiais. 

Cada tipo de casa é representado por um código inteiro no intervalo [1,50].
Por exemplo:  
\begin{itemize}
\item 1: moderno
\item 2: fazenda
\item 3: colonial, {\bf ...}
\end{itemize}

Cada tipo de material é representado por um código inteiro no intervalo
[1,100].  Por exemplo: 
\begin{itemize}
\item 1: ferro
\item 2: madeira
\item 3: vidro
\item 4: tinta
\item 5: tijolo, {\bf ...}
\end{itemize}

Em um segundo arquivo, chamado ``preco.dat'', encontram-se os
preços de cada um dos materiais.
Este também é um {\em arquivo de registros} contendo: o código do material
e o seu 
respectivo preço.   O código do material segue a mesma codificação
utilizada pelo arquivo de materiais.

Escreva um programa \emph{Pascal} que leia os dados do arquivo ``material.dat'' em
uma matriz e o dados do arquivo ``preco.dat'' em um vetor, como ilustrado
abaixo.

\item Usando as estruturas de dados abaixo escreva um procedimento em
\emph{Pascal} que recebe como parâmetro uma estrutura do tipo 
\verb+TAGENDA+ e ordena de forma crescente o vetor \verb+pessoa+ 
dessa estrutura tomando como referência para a ordenação  
o campo \verb+nome+ da estrutura \verb+TPESSOA+. Ou seja,
ordena uma agenda pessoal de telefones e endereços em ordem 
crescente do nome das pessoas presentes na agenda.
Você \emph{deve} usar a função $compara( r, s )$, que recebe dois 
parâmetros do tipo \verb+string+ e retorna 0 se $r$ e $s$ são
iguais, 1 se $r$ é lexicograficamente maior que $s$ e $-1$ 
se $r$ é lexicograficamente menor que $s$. Um nome $n_1$ é 
lexicograficamente maior que um nome $n_2$ se $n_1$ aparece 
depois de $n_2$ numa ordenação alfabética crescente desses
nomes.
\begin{center}
\begin{small}
\begin{verbatim}
Const
  MAX = 1000;
Type
   TPESSOA = record
                nome: string;
                telefone: string;
                endereco: string
             end; 
   TAGENDA = record
                pessoa: array [1..MAX] of TPESSOA;
                tamanho: integer
             end;
\end{verbatim}
\end{small}
\end{center}

\item Uma matriz é dita esparsa quando a maioria dos seus elementos possui valor $0.0$
(zero). Neste caso, a representação da matriz sob a forma tradicional (um
\emph{array} bidimensional) implica em uma utilização ineficiente da memória.
Por isso, matrizes esparsas são freqüentemente representadas como vetores de
elementos não nulos, sendo que cada elemento contém suas coordenadas e seu
valor.

Exemplo:
\begin{displaymath}
    \mathbf{M} = \left[ \begin{array}{cccc}
                         0 & 0 & 0 & 1.2 \\
                         7.3 & 0 & 99 & 0 \\
                         0 & 2 & 0 & 0 \\
                         0 & 17 & 0 & 0
                        \end{array} \right] \Longleftrightarrow   
    \mathbf{M_e} = \left[ \begin{array}{ccccc}
                         \begin{array}{|c|c|}
                                1 & 4 \\ \hline \multicolumn{2}{|c|}{1.2}
                               \end{array} &
                         \begin{array}{|c|c|}
                                2 & 1 \\ \hline \multicolumn{2}{|c|}{7.3}
                               \end{array} &
                         \begin{array}{|c|c|}
                                2 & 3 \\ \hline \multicolumn{2}{|c|}{99}
                               \end{array} &
                         \begin{array}{|c|c|}
                                3 & 2 \\ \hline \multicolumn{2}{|c|}{2}
                               \end{array} &
                         \begin{array}{|c|c|}
                                4 & 2 \\ \hline \multicolumn{2}{|c|}{17}
                               \end{array}
                    \end{array} \right]
\end{displaymath}
Para representar estas matrizes em \emph{Pascal}, podemos definir as
seguintes estruturas de dados:
\begin{lstlisting}
Const MAX = 1000; MAX_ESP = MAX*MAX/10;
Type t_matriz = record
        lin,col : integer;
        dados : array [1..MAX, 1..MAX] of real;
     end;
     elemento = record
        l,c : integer;
        val : real;
     end;
     t_matrizesp = record
        tam : integer;
        dados : array [1..MAX_ESP] of elemento;
     end;
\end{lstlisting}

Utilizando as estruturas de dados definidas acima, faça:
\begin {enumerate}

\item  Escreva uma função que transforme uma matriz do tipo
\verb|t_matriz| em uma matriz do tipo \verb|t_matrizesp|.

\item  Escreva uma função que transforme uma matriz do tipo
\verb|t_matrizesp| em uma matriz do tipo \verb|t_matriz|.
 
\item  Escreva uma função que receba duas matrizes do tipo 
\verb|t_matrizesp| e imprima o resultado da \textbf{soma} destas matrizes. O
resultado deve ser impresso na forma bidimensional, com os valores de cada
linha separados por espaços.

\end{enumerate}

\item Verdadeiro ou falso: 
\begin{itemize}
   \item  um record deve ter pelo menos dois campos
   \item  os campos de um record tem que ter nomes diferentes
   \item  um record deve ter um nome diferente de qualquer um dos seus campos.
\end{itemize}

\item Suponha que a linguagem \emph{Pascal} foi modificada para permitir que o 
   símbolo ponto "." possa fazer parte de identificadores. Qual problema
   isto poderia causar? Dê um exemplo.

\item Esta definição é legal? Porque não? 

\begin{verbatim}
   TYPE 
        Ponto = RECORD
                    quantidade: integer;
                    corte: Tamanho;
                END;
        Tamanho = (mini, medio, maxi);
\end{verbatim}

\item 
 Latitudes e  longitudes são especificadas em graus  (o), minutos ('),
   segundos ('') e direção (norte, sul, leste, oeste). Suponha que uma
   cidade   esteja   na    latitude   22o17'34''   norte   e   longitude
   53o41'9''oeste.  Armazene esta localização  na variável  Cidade, como
   declarada abaixo:
    
\begin{verbatim}
   TYPE 
        TipoDirecao = (norte, sul, leste, oeste);
        Coordenadas = RECORD
                          graus: 0..180;
                          minutos, segundos: 0..60;
                          direcao: TipoDirecao;
                      END;
        Localizacao = RECORD
                          latitude, longitude: Coordenadas;
                      END
   VAR
        Cidade: Localizacao;
\end{verbatim}

\item Suponha que temos as seguintes definições e declarações abaixo:

\begin{verbatim}
   TYPE 
        NumTelefone = RECORD
                          Area, Prefixo, Numero: integer;
                      END;
   VAR
        Casa, Escritorio, Celular: NumTelefone;
\end{verbatim}

   Escreva código \emph{Pascal} par testar  se Escritorio e Celular estão sobre
   o mesmo código de área e para atribuir o mesmo número do Celular como
   sendo o do Escritório.

\item Criar registros para as seguintes configurações da vida real:
\begin{itemize}
  \item Pessoas com nome, endereço, telefone, sexo, idade e salário;
   \item Planetas  com massa, distância  média do sol, número  de satélites,
     nome, diâmetro. 
   \item Cursos,  com alunos e suas  notas, períodos em  que são oferecidos,
     professor, horário.
\end{itemize}

\item Uma matriz é dita \textit{esparsa} se o 
número de elementos não nulos for bastante pequeno com relação
ao número total de elementos da matriz. Você deve fazer um programa
que leia do teclado uma matriz qualquer de números \textit{reais} e crie um 
vetor que armazene somente os elementos não nulos da matriz. Cada
posição do vetor deve ser um registro contendo o valor do elemento,
e a posição desse elemento na matriz (linha e coluna).
Imprima o resultado. A maneira de definir o vetor faz parte da prova.
Exemplo:
Seja a matriz $4 \times 5$ abaixo:

\begin{center}
\begin{tabular}{|l|l|l|l|l|}  \hline
0.0  & 0.0 & 3.0 & 0.0  & 1.7 \\ \hline
-1.1 & 0.0 & 0.0 & 0.0  & 0.0 \\ \hline
0.0  & 0.0 & 0.0 & -2.1 & 0.0 \\ \hline
0.0  & 0.0 & 2.5 & 0.0  & 0.0 \\ \hline
\end{tabular}
\end{center}

Seu programa deverá construir um 
vetor que permita imprimrir as seguintes informações:

\begin{itemize}
\item o elemento 3.0 está na posição (1,3) do vetor;
\item o elemento 1.7 está na posição (1,5) do vetor;
\item o elemento -1.1 está na posição (2,1) do vetor;
\item o elemento -2.1 está na posição (3,4) do vetor;
\item o elemento 2.5 está na posição (4,3) do vetor;
\end{itemize}

\item Considere uma estrutura de vetores para representar uma matriz 
esparsa, tal como você definiu na questão anterior. Faça
um procedimento para imprimir a matriz completa, contendo todos
os elementos nulos e não nulos 
(não precisa fazer o programa todo, basta o procedimento).
Por exemplo, dado vetor com as informações descritas no 
exemplo da questão anterior, a saída do seu programa deve
ser exatamente a matriz apresentada no início do exemplo.

\item Considere o tipo PGM para imagens como definido na seção~\ref{pgm}.
Nas questões que seguem, considere as seguintes estruturas de dados e 
assinaturas de funções e procedimentos:

\begin{lstlisting}
const MAX=10000;

type
     matriz = array [1..MAX,1..MAX] of integer;

     vetor  = array [1..MAX] of integer;

     imagem = record
                 col, lin, maior: integer;
                 m: matriz;
     end;

     imgcompactada = record
                 tam: integer;
                 v: vetor;
     end;
  
function calcula_valor_medio (var I: imagem): integer;
(* funcao que retorna o valor medio dos pixels da imagem, isto eh
   a soma de todos os elementos dividido pelo numero de elementos *)

procedure ler (var I: imagem);
(* procedimento que le uma imagem no formato PGM *)

procedure imprime_imagem (var I: imagem);
(* procedimento que imprime uma imagem no formato PGM *)
procedure binariza (var I: imagem; limiar: integer);
(* procedimento que transforma a imagem de tons de cinza para preto e branco
   para isto, os pixels que forem maiores que o limiar devem se tornar brancos
   e os que forem menores ou iguais a este mesmo limiar devem se tornar pretos *)

procedure compacta_imagem (var I: imagem; var C: imgcompactada);
(* procedimento que recebe uma imagem no formato PGM e cria um vetor C
   que eh uma representacao compactada desta                           *)

procedure imprime_img_compactada (var C: imgcompactada);
(* procedure que recebe uma imagem compactada e a imprime no formato PGM *)
\end{lstlisting}

\begin {enumerate}

\item  Implemente estas funções e procedimentos e faça um programa que 
receba um certo número $N$ de imagens PGM em tons de cinza (onde 0
representa preto e branco é representado pelo maior valor da imagem) e
imprima a imagem binarizada, isto é, em preto e branco (onde 0 
representa preto e 1 representa branco). Note que o limiar é obtido
pelo valor médio dos pixels.

\item 
Implemente um procedimento que gere um vetor que representa a matriz 
binarizada de forma compacta. Para isto, use a seguinte ideia: como a
matriz só tem zeros e uns, vamos substituir sequências de uns pelo número
de uns consecutivos. Os elementos vão sendo colocados no vetor, de maneira
linear, cada linha seguinte é concatenada à anterior. Veja o exemplo:
Exemplo:
\begin{itemize}
\vspace*{-2mm}      
    \item \textbf{Imagem binarizada}:
    \begin{verbatim}
    P2
    11 10
    1
    1  1  1  1  0  1  1  1  1  1  0 
    1  1  0  1  1  1  1  1  1  1  1 
    0  0  1  0  0  0  1  1  1  0  0
    1  1  1  1  1  1  1  1  1  1  1
    0  0  0  1  1  1  1  1  0  0  0
    0  0  0  1  1  1  1  1  1  1  1
    1  1  1  0  1  1  1  1  1  1  1
    1  1  1  1  1  1  1  0  1  1  1
    1  1  1  1  1  1  1  1  1  0  0
    0  1  1  1  1  1  1  1  1  1  1
    \end{verbatim}

\vspace*{-4mm}      
    \item \textbf{Imagem compactada}:
    \begin{verbatim}
36
4 0 5 0 2 0 8 0 0 1 0 0 0 3 0 0 11 0 0 0 5 0 0 0 0 0 0 11 0 14 0 12 0 0 0 10
\end{verbatim}
\end{itemize}

Isto é, a primeira linha da matriz possui 4 uns consecutivos seguido de um
zero e outros 5 uns consecutivos, por isto, o vetor contém seus primeiros
elementos ``4, 0 e 5''. Preste atenção antes de escrever o código. Você pode 
definir, se precisar, funções, procedimentos ou estruturas de dados adicionais.
\end{enumerate}



\end{enumerate}
\item Defina um Tipo Abstrato de Dados \emph{racional} que vai procurar
      abstrair números da forma $\frac{A}{B}$, onde $A$ e$B$ são
      números inteiros. Em seguida implemente as funções e procedimentos
      necessários para realizar as operações abaixo de maneira que os
      resultados sejam sempre simplificados, isto é, o resultado final
      deve indicar $\frac{3}{2}$ e não $\frac{6}{4}$, por exemplo. 
      Suas implementações não podem permitir que ocorram divisões por zero.
      \begin{enumerate}
          \item adição de duas frações;
          \item subtração de duas frações;
          \item multiplicação de duas frações;
          \item divisão de duas frações.
      \end{enumerate}

\item Sem olhar os códigos escritos neste capítulo, implemente sua 
      própria biblioteca que implementa o TAD pilha. Os algoritmos
      que estão ali são triviais mas servem para ver sua prática em 
      programação.

\item Sem olhar os códigos escritos neste capítulo, implemente sua 
      própria biblioteca que implementa o TAD conjunto. Alguns dos algoritmos
      que estão ali \emph{não} são triviais e é um ótimo exercício de 
      programação.

\item Resolva o exercício que está na seguinte URL: \\
\url{http://www.inf.ufpr.br/cursos/ci055/tad_conjunto/enunciado_tad.pdf}

\item Resolva o exercício que está na seguinte URL: \\
\url{http://www.inf.ufpr.br/cursos/ci055/Provas_antigas/final-20191.pdf}

\item Resolva o exercício que está na seguinte URL: \\
\url{http://www.inf.ufpr.br/cursos/ci055/Provas_antigas/p3-20191.pdf}

\item Considere um Tipo Abstrato de Dados \emph{Fila}, que define
uma estrutura na qual o primeiro que entra é o primeiro que sai
(FIFO, do inglês \emph{First In, First Out}). Pense em uma fila
de uma padaria, por exemplo. As principais operações que manipulam
filas são as seguintes:

\begin{itemize}
   \item criar uma fila (vazia);
   \item inserir elementos;
   \item remover elementos;
   \item retornar o tamanho da fila;
   \item saber se a fila está vazia/cheia;
   \item imprimir a fila como está;
   \item retornar o elemento do início da fila, removendo-o;
   \item retornar o elemento do início da fila, sem removê-lo.
\end{itemize}

\item Considere um Tipo Abstrato de Dados \emph{lista}, que define
uma estrutura que pode conter elementos em qualquer ordem ou mesmo
repetidos. Pense por exemplo em uma lista de compras ou de afazeres.
As principais operações que manipulam listas são as seguintes:
\begin{itemize}
   \item criar uma lista (vazia);
   \item inserir no início;
   \item inserir no fim;
   \item inserir na posição p;
   \item remover (do início, do fim, da posição p);
   \item retornar o tamanho da lista;
   \item saber se a lista está vazia/cheia;
   \item imprimir a lista como está;
   \item imprimir a lista ordenada;
   \item fundir duas listas;
   \item intercalar duas listas;
   \item pesquisar o elemento da posição p na lista;
   \item copiar uma lista em outra;
\end{itemize}

\item Implemente um programa que encontra bilhetes premiados do jogo da mega-sena, usando a sua implementação do tipo lista acima definido.

\item Defina o Tipo Abstrato de Dados \textsf{polinomio}. A estrutura tem
que ser capaz de armazenar o grau e os coeficientes de um polinômio
$a_0 + a_1x + a_2x^2 + \ldots + a_nx^n$. Implemente o conjunto de
operações abaixo na forma de funções e procedimentos:

\begin{enumerate}
\item inicializar a estrutura polinômio;
\item ler um polinômio de grau $n$;
\item dado $x \in R$, calcular o valor de $P(x)$;
\item obter o polinômio derivada de $P$, $P'$.
\item dado $x \in R$, calcular o valor de $P'(x)$;
\item obter o polinômio soma de $P$ e $Q$;
\item obter o polinômio multiplicação de $P$ e $Q$;
\end{enumerate}

Faça um programa em \emph{Pascal} que utilize o tipo abstrato de dados
definido, leia dois polinômios $p$ e $q$, calcule
o produto $r$ de $p$ e $q$, imprima o polinômio resultante, 
leia um certo número real $x$, calcule o valor de $r(x)$ e o imprima. 

\end{enumerate}
\item Dados  dois números inteiros  positivos determinar o valor  da maior
    potência do primeiro que divide  o segundo. Se o primeiro não divide
    o segundo, a maior potência é definida como sendo igual a 1. Por exemplo, a
    maior potência de 3 que divide 45 é 9.

\begin{minipage}{5cm}
\begin{verbatim}
Entrada:
3 45
\end{verbatim}
\end{minipage} \
\begin{minipage}{5cm}
\begin{verbatim}
Saída:
9
\end{verbatim}
\end{minipage}


% laco dentro de if

\item Dadas as populações $P_A$ e $P_B$ de duas cidades $A$ e $B$ em 2009, e
suas respectivas taxas de crescimento anual $X_A$ e $X_B$, faça um
programa em \emph{Pascal} que receba estas informações como entrada e
determine:
\begin{itemize}
\item
se a população da cidade de menor população ultrapassará a de maior
população;
\item
e o ano em que isto ocorrerá.
\end{itemize}

% if dentro de while

\item Um inteiro positivo $N$ é perfeito se for igual a soma de seus
divisores positivos diferentes de $N$.

Exemplo: 6 é perfeito pois $1 + 2 + 3 = 6$ e $1, 2, 3$ são todos os
divisores positivos de 6 e que são diferentes de 6.

Faça um programa em \emph{Pascal} que recebe como entrada um número
positivo $K$ e mostre os $K$ primeiros números perfeitos.


\item Faça um  programa em \emph{Pascal} que dado um inteiro positivo $n$, escreva
todos os termos, do primeiro ao $n$-ésimo, da série abaixo.  Você pode
assumir que o usuário nunca digita valores menores que 1 para $n$.

\[ 5,6,11,12,17,18,23,24, \ldots\]

% laco com varios ifs aninhados

\item Faça um programa em \emph{Pascal} que, dada uma sequência de números naturais positivos terminada por $0$ (zero), imprimir o histograma da sequência dividido em quatro faixas (o histograma é a contagem do número de elementos em cada faixa):
\begin{itemize}
 \item Faixa 1: $1$ -- $100$;
 \item Faixa 2: $101$ -- $250$;
 \item Faixa 3: $251$ -- $20000$;
 \item Faixa 4: acima de $20001$.
\end{itemize}

Exemplo:
\begin{verbatim}
Entrada: 347 200 3 32000 400 10 20 25 0
Saída:  Faixa 1: 4
        Faixa 2: 1
        Faixa 3: 2
        Faixa 4: 1
\end{verbatim}

%%% laço duplo

\item Fazer um programa em \emph{Pascal} que leia uma sequência de
 pares de números inteiros quaisquer, sendo dois inteiros por linha de
entrada. A entrada de dados termina quando os dois números lidos forem nulos.
Este par de zeros não deve ser processado e serve para marcar o
término da entrada de dados.

Para cada par $A,B$ de números lidos, se $B$ for maior do que
$A$, imprimir a sequência $A,A+1, \ldots, B-1,B$. Caso contrário,
imprimir a sequência $B,B+1, \ldots,A-1,A$.

Exemplos:
\begin{verbatim}
Entrada      Saida
4 6          4 5 6
-2 1         -2 -1 0 1
2 -3         -3 -2 -1 0 1 2
0 0 
\end{verbatim}


\item  Fazer um programa em \emph{Pascal} que receba um
   número inteiro $N$ como entrada e imprima cinco linhas
contendo as seguintes somas, uma em cada linha:

\begin{verbatim}
   N
   N + N
   N + N + N
   N + N + N + N
   N + N + N + N + N
\end{verbatim}

Exemplo:

\begin{minipage}{5cm}
\begin{verbatim}
Entrada:
3
\end{verbatim}
\end{minipage} \
\begin{minipage}{5cm}
\begin{verbatim}
Saída:
   3
   6
   9
   12
   15
\end{verbatim}
\end{minipage}

\item Fazer um programa em \emph{Pascal} que imprima
  exatamente a saída especificada na figura 1 (abaixo) de maneira que,
  em todo o programa fonte, não apareçam mais do que três comandos de impressão.

\begin{center}
\begin{minipage}{5cm}
\begin{verbatim}
1
121
12321
1234321
123454321
12345654321
1234567654321
123456787654321
12345678987654321

    Figura 1
\end{verbatim}
\end{minipage}
\end{center}

\item Fazer um programa em {\emph Pascal} que imprima
  exatamente a mesma saída solicitada no exercício anterior, mas que
  use exatamente dois comandos de repetição.

\item Adaptar a solução do exercício anterior para que a saída seja
  exatamente conforme especificada na figura 2 (abaixo).

\begin{center}
\begin{minipage}{5cm}
\begin{verbatim}
        1
       121
      12321
     1234321
    123454321
   12345654321
  1234567654321
 123456787654321
12345678987654321

    Figura 2
\end{verbatim}
\end{minipage}
\end{center}

% laço duplo com if dentro

\item Leia do teclado uma sequência de  $N > 0$ números quaisquer. Para cada
valor lido, se ele for positivo, imprimir os primeiros 10 múltiplos
dele.

% estrutura complexa com varios whiles e ifs

\item Sabe-se que um número da forma $n^3$ é igual a soma de $n$ números
ímpares consecutivos.

Exemplos:
\begin{itemize}
\item
$1^3 = 1$
\item
$2^3 = 3 + 5$
\item
$3^3 = 7 + 9 + 11$
\item
$4^3 = 13 + 15 + 17 + 19$
\end{itemize}

Dado $M$, escreva um program em \emph{Pascal} que determine os ímpares
consecutivos cuja soma é igual a $n^3$ para $n$ assumindo valores de
1 a $M$.

\item Faça um programa em {\em  \emph{Pascal}} que, dados
dois números naturais  $m$ e $n$  determinar,  entre todos  os pares de
números naturais $(x,y)$ tais que $x<=m$ e $y<=n$, um  par para o qual
o valor da expressão $xy - x^2 + y$ seja máximo e calcular também esse
máximo.

\item (*) Escreva um programa em \emph{Pascal} para ler uma sequência de
números inteiros, terminada em $-1$. Para cada número inteiro lido, o programa
deve verificar se este número está na base binária, ou seja, se é composto
somente
pelos dígitos $0$ e $1$. Caso o número esteja na base binária, o programa deve
imprimir seu valor na base decimal. Caso contrário, deve imprimir uma
mensagem indicando que o número não é binário. Ao final do programa deve ser
impresso, em formato decimal, o maior número válido (binário) da sequência.

\vspace*{0.25cm}

\noindent Dica: dado o número $10011$ em base binária, seu valor correspondente
em base decimal será dado por
\begin{equation*}
1.2^4 + 0.2^3 + 0.2^2 + 1.2^1 + 1.2^0 = 19 
\end{equation*}


\vspace*{0.25cm}

\noindent {\bf Exemplo:}
\begin{verbatim}
Entrada:    Saida:
10011       19
121         numero nao binario
1010        10
101010101   341
0           0
-1

O maior numero binario foi 341
\end{verbatim}




\end{enumerate}

\item Faça  um programa que leia e  armazene em um vetor  uma sequência de
inteiros.  Em seguida  o programa  deve  ler uma  sequência de  inteiros
informados pelo usuário e, para cada  um deles, dizer se ele pertence ou
não ao vetor armazenado previamente. 

\item Faça um  programa que  leia duas  sequências de  $n$ inteiros  em dois
vetores distintos,  digamos, $v$ e  $w$ e verifique  se os dois  vetores são
idênticos. 

\item Faça um programa em  que leia dois vetores de números reais
e descubra se um deles é permutação do outro, isto é, se eles
tem os mesmos elementos, ainda que em ordem diferente.
A quantidade de elementos lidos em cada vetor é no  máximo 100,  e
cada sequência termina quando o valor 0 é digitado. 
Por   exemplo: 

        $[2,2,0,3,4]$   e  $[2,2,0,3,4]$:   sim.
  
        $[2,2,0,3,4]$ e  $[4,3,2,0,2]$: sim.
        
        $[2,2,0,3,4]$ e $[4,3,4,0,2]$: não. 
        
        $[3,0,5]$ e $[3,0,5,3]$: não.

Implemente três
versões deste problema:
\begin{itemize}
\item ordenando os vetores para em seguida compará-los;
\item sem ordenar os vetores;
\item crie uma
 função que  retorna  0 se $x$  não  pertence a  $v$ e  caso contrário
 retorna o índice  do vetor onde  $x$  se encontra. Use esta função para 
 resolver este problema. 
\end{itemize}




\item Faça  um  programa  que   leia  duas  sequências  de  inteiros,  não
necessariamente  contendo a  mesma quantidade  de números. Seu programa
deverá:
\begin{itemize} 
\item dizer  se a segunda sequência está contida na primeira. Exemplo:
\begin{verbatim}
v1: 7 3 2 3 2 6 4 7 
v2: 3 2 6
Saída: sim
\end{verbatim}
\item construir um terceiro  vetor, sem  destruir os  originais, que é  
      a concatenação  do primeiro com o segundo;
\begin{verbatim}
v1: 7 3 2 6
v2: 5 1 8 4 9
Saída: 1 2 3 4 5 6 7 8 9
\end{verbatim}
\item ordená-los, e em seguida imprimir todos os números ordenados 
      em ordem crescente. Exemplo:
\begin{verbatim}
v1: 7 3 2 6
v2: 5 1 8 4 9
Saída: 1 2 3 4 5 6 7 8 9
\end{verbatim}
\end{itemize}

\item Crie uma função que receba um vetor de inteiros de 
     tamanho $n$ e devolva o valor \emph{true} se o vetor estiver ordenado e 
     \emph{false} em caso contrário.

\item Aproveitando as soluções dos problemas anteriores, escreva um programa
     que leia dois vetores de inteiros $v$ e $w$, 
     de dimensões $m$ e $n$ 
     respectivamente, verifique se eles estão ordenados, ordene-os em caso 
     contrário e, em seguida, imprima a intercalação dos dois. \\
     Exemplo de intercalação: $v$: 1 4 6 9; $w$: 2, 3, 5, 7. \\
     Saída: 1, 2, 3, 4, 5, 6, 7, 9. 

\item Dados dois números naturais $m$ e $n$, uma frase com $m$ letras
e uma palavra com $n$ letras, escreva um procedimento que determine o número de
vezes que a palavra ocorre na frase e a posição em que cada ocorrência inicia.

    Exemplo:
    \begin{verbatim}
    Para M = 30, N = 3, a palavra ANA e a frase:
        ANA E MARIANA GOSTAM DE BANANA
    A palavra ANA ocorre 4 vezes, nas posições 1, 11, 26, 28.
    \end{verbatim}

\item Dada uma sequência de $N$ números, determinar quantos números dintintos
compõe  a sequência e  o número  de vezes  que cada  um deles  ocorre na
mesma. Exemplo:

N=5
1 2 3 2 3 
a sequência tem três números distintos, 1, 2 e 3. Ocorrências:
1 ocorre 1 vez
2 ocorre 2 vezes
3 ocorre 2 vezes

\item Dadas  duas  sequências  com  $n$  números  inteiros  entre  0  e  1,
interpretados como números binários:
\begin{enumerate}
     \item imprimir o valor decimal dos números;
     \item calcular a soma de ambos (em binário), usando o ``vai-um'';
     \item imprimir o valor decimal da soma.
\end{enumerate}


\item Escreva um programa em  que leia os seguintes valores:
um inteiro $B$, um inteiro $N$ ($1 \leq N \leq 10$), e $N$ valores inteiros.
A ideia é que estes valores sejam entendidos como a representação
de um número não negativo na base $B$. 
Estes valores deverão ser inseridos em um vetor de tamanho $N+1$, onde
a primeira posição armazena a base $B$ e as outras $N$ posições
o restante dos números lidos. 
%
Note que o  intervalo de valores possíveis para cada dígito na
base $B$ é $[0, B-1]$.
%
Seu programa deve retornar o valor em decimal do número representado
no vetor. Se o número representado no vetor não for válido na
base $B$ então deverá ser retornado o código de erro ``-1''.
Por exemplo, se $B=3$ o número 2102 na base 3 equivale ao valor decimal 65;
se $B=4$ o número $35$ é inválido na base 4.


\item Faça um programa que, 
dadas duas sequências com
$N$ números inteiros entre 0 e 9, interpretadas como dois números
inteiros de $N$ algarismos, calcular a sequência de números que
representa a soma dos dois inteiros, usando o ``vai-um''. Por exemplo:\\

\verb|        N=6,|\\
\verb|                4 3 4 2 5 1|\\
\verb|              + 7 5 2 3 3 7|\\
\verb|              1 1 8 6 5 8 8|



\item Dada  uma  sequência  $x_1$,  $x_2$, \ldots,  $x_n$  de  
números  inteiros,
determinar um segmento de soma  máxima.  Exemplo: na sequência 5, 2, -2,
-7, 3, 14,  10, -3, 9, -6, 4,  1, a soma do maior segmento  é 33, obtida
pela soma dos números de 3 até 9. 
 
\item Implemente um programa que leia um vetor de 1 milhão de inteiros
   em um vetor de inteiros. Gere um número aleatório e o procure
   neste vetor de duas maneiras diferentes: uma usando busca com 
   sentinela e outra usando busca binária. Seu programa deve imprimir
   uma tabela com o número de comparações feitas em cada um dos casos
   acima (busca com sentinela e busca binária). Desconsidere o tempo
   gasto com ordenação no caso da busca binária. A busca com sentinela
   deve ser feita em um vetor não ordenado. Gere 200 números aleatórios
   e imprima a média de comparações para cada um dos dois algoritmos
   sendo testados.

\item 
Suponha que um ex\'ercito tenha 20 regimentos e que eles est\~ao em processo
de forma\c c\~ao. Inicialmente o primeiro tem 1000 homens, o segundo 950,
o terceiro 900, e assim por diante, at\'e o vig\'esimo que tem 50. Suponhamos
que a cada semana 100 homens s\~ao enviados para cada regimento, e no final
da semana o maior regimento \'e enviado para o {\em front}. Imaginemos que o
general do quinto regimento \'e companheiro de xadrez do comandante supremo,
e que eles est\~ao no meio de uma partida. O comandante supremo ent\~ao
envia apenas 30 homens para o quinto regimento a cada semana, esperando com
isto poder acabar o jogo com seu colega.
Escreva um programa em 
que diga, a cada semana, qual \'e o regimento enviado ao {\em front} e mostre o {\em status} dos outros regimentos. O programa
deve tamb\'em determinar exatamente quantas semanas levar\'a o quinto regimento
para ser deslocado ao {\em front}. 

\item Suponha que voc\^e esteja usando o m\'etodo da ordenação 
por sele\c c\~ao. Qual das sequências abaixo requerir\'a o menor n\'umero
de trocas? Quantas? Qual requerir\'a o maior n\'umero de trocas? Quantas?
Explique.
\begin {enumerate}
\item 10, 9, 8, 7, 6, 5, 4, 3, 2, 1.
\item 5, 4, 3, 2, 1, 10, 9, 8, 7, 6.
\item 10, 1, 9, 2, 8, 3, 7, 4, 6, 5.
\item 2, 3, 4, 5, 6, 7, 8, 9, 10, 1.
\item 1, 10, 2, 9, 3, 8, 4, 7, 5, 6.
\end {enumerate}

\item Suponha que voc\^e tem uma vari\'avel do tipo vetor declarada como:
\emph{array [1..50] of real;}. 
Fa\c ca uma fun\c c\~ao 
que inicialize o vetor de modo que os elementos
de \'{\i}ndices \'{\i}mpares recebam o valor inicial -2.0 e os elementos
de \'{\i}ndices pares recebam o valor inicial 7.0. Sua função deve
fazer uso de um único comando de repetição, que incrementa de um em um, e de 
nenhum comando de desvio condicional.

\item Qual dos seguintes problemas requer o uso de vetores para uma solu\c c\~ao elegante?
\begin {enumerate}
\item Ler cerca de duzentos n\'umeros e imprimir os que est\~ao em uma certa faixa;
\item Computar a soma de uma sequ\^encia de n\'umeros;
\item Ler exatamente duzentos n\'umeros e orden\'a-los em ordem crescente;
\item Encontrar o segundo menor elemento de uma sequ\^encia de entrada;
\item Encontrar o menor inteiro de uma sequ\^encia de inteiros.
\end {enumerate}

\item Considere um vetor  declarado como: 
\emph{array [1..50] of integer} que tem a 
particularidade de todos os elementos estarem entre 1 e 30, sendo que
nenhum \'e repetido. Fa\c ca um programa
que ordene o vetor de maneira eficiente explorando esta característica e fazendo
o menor n\'umero poss\'{\i}vel de trocas.

\item   Dada uma sequência $x_1, x_2, \ldots, x_k$ de números
  reais, verifique  se existem dois segmentos  consecutivos iguais nesta
  sequência, isto é, se existem $i$ e $m$ tais que:
\[ x_i, x_{i+1}, \ldots, x_{i+m-1}=x_{i+m}, x_{i+m+1}, \ldots, x_{i+2m-1}.
\]
Imprima, caso existam,  os valores de $i$ e de  $m$. Caso contrário, não
imprima  nada. Exemplo:  Na sequência  7,9,5,4,5,4,8,6, existem  $i=3$ e
$m=2$. 

\item   Um coeficiente binomial, geralmente denotado
  $\binom{n}{k}$, representa o número de possíveis combinações de $n$
  elementos tomados $k$ a $k$. Um ``Triângulo de Pascal'', uma homenagem
  ao grande matemático Blaise Pascal, é uma tabela de valores de
  coeficientes combinatoriais para pequenos valores de $n$ e $k$. Os
  números que não são mostrados na tabela têm valor zero. Este triângulo
  pode ser construído automaticamente usando-se uma propriedade
  conhecida dos coeficientes binomiais, denominada ``fórmula da
  adição'':
$\binom{r}{k} = \binom{r-1}{k} + \binom{r-1}{k-1}.$
Ou seja, cada elemento do triângulo é a soma de dois elementos da linha
anterior, um da mesma coluna e um da coluna anterior. 
Veja  um  exemplo de  um  triângulo  de Pascal  com  7  linhas:
\[\begin{array}{ccccccc}
1 \\
1 & 1 \\
1 & 2 & 1 \\
1 & 3 & 3 & 1 \\
1 & 4 & 6 & 4 & 1 \\
1 & 5 & 10 & 10 & 5 & 1 \\
1 & 6 & 15 & 20 & 15 & 6 & 1 \\
\end{array}
\]
Faça um programa que imprima na tela um triângulo de Pascal
com 10 linhas.  Seu programa deve obrigatoriamente fazer uso de
exatamente dois vetores durante o processo de construção. Um deles
conterá a última linha ímpar gerada, enquanto que o outro conterá a
última linha par gerada. Lembre-se que os elementos que não aparecem na
tabela tem valor nulo. Você deve sempre ter o controle do tamanho da
última linha impressa (o tamanho útil dos vetores em cada passo). Você
deve também usar um procedimento para imprimir o vetor. Observe que não
há entrada de dados, os dois vetores são gerados, um a partir do outro.
O único elemento da primeira linha tem o valor 1. Você deve
obrigatoriamente declarar um tipo vetor com tamanho máximo
Tam\_max\_vetor, e o seu programa deverá tomar cuidado para manipular
corretamente vetores de tamanho menor do que o tamanho máximo, impedindo
que haja uma atribuição em posição ilegal de memória. 


\item Resolva o problema do triângulo de Pascal usando somente um vetor.

\item Seja um polinômio $p(x)= a_0 + a_1 x + a_2 x^2 + \ldots + a_n x^n$ de
  grau $n \ge 2$. Uma possível maneira de calcular uma raiz do polinômio
  é pelo ``método de Newton''. Este método consiste em se fornecer uma
  aproximação inicial para a raiz, isto é, um valor que não é a raiz
  exata, mas é um valor próximo.  Assim, se $x_0$ é esta
  aproximação inicial, $p(x_0)$ não é zero mas espera-se que
  seja próximo de zero.  A obtenção da raiz pelo método de Newton é
  feita pelo refinamento desta solução inicial, isto é, pela tentativa
  de minimizar o erro cometido. Isto é feito pela expressão seguinte:
\[x_{n+1}=x_{n}-\frac{p(x_{n})}{p\prime(x_{n})},\]  $n=0,1,2,\ldots$,  e
  onde $p\prime(x)$ é a primeira derivada de $p(x$). Usualmente, repete-se
  este refinamento até que $|x_{n+1}-x_{n}| < \epsilon, \epsilon>0$, ou
  até que $m$ iterações tenham sido executadas. \\
  Construa um programa em  que receba como dados de entrada 
  um polinômio $p(x)= a_0 + a_1 x + a_2 x^2 + \ldots + a_n x^n$ e
  uma  aproximação inicial  $x_0$ da  raiz de  $p(x)$, $\epsilon>0$  e o
  número  máximo de  iterações, e  calcule  uma aproximação  da raiz  de
  $p(x)$ pelo método de Newton. Utilize obrigatoriamente um procedimento
  que receba como parâmetro  um polinômio $p(x)$ (incluindo a informação
  sobre o grau do polinômio) e que calcule e retorne a função
  derivada  $p\prime(x)$.  Utilize também  uma  função  que receba  como
  parâmetros um polinômio $p(x)$ e um valor real $\overline{x}$ e retorne
  o   valor    do   polinômio    no   ponto   $\overline{x}$,    isto   é
  $p(\overline{x})$. Use  esta função para  calcular, a cada  iteração do
  método    de    Newton,    os    valores   de    $p(x_{n})$    e    de
  $p\prime(x_{n})$.  

\item Faça um programa em  que leia uma sequência de 10 
     letras (caracteres de A a Z), as armazene em um vetor de 10 posições 
     e imprima a lista de letras repetidas no vetor. Sendo assim, para os 
     dados: A J G A D F G A A, a saída deve ser: A G.

\item Escreva o programa da busca binária de um valor $x$ num 
     vetor de inteiros que, ao invés de achar a primeira ocorrência do valor 
     na lista, identifique e imprima o menor índice do vetor no qual o valor 
     ocorra.

\item Escreva um programa que leia uma sequência de {\em código de
operação} e {\em valor}, onde o {\em código de operação} é um inteiro com
os seguintes valores:
\begin{itemize}
\item 0 (zero): fim
\item 1 (um): inserção
\item 2 (dois): remoção
\end{itemize} 

O {\em valor} lido é um real que deve ser inserido em um vetor (caso a
operação seja 1), ou removido do vetor (caso a operação seja 2).   As
inserções no vetor devem ser realizadas de forma que o vetor esteja sempre
ordenado.   No final do programa o vetor resultante deve ser impresso.

Detalhamento:
\begin{itemize}
\item a quantidade máxima de valores que pode  ser inserida é 100;
\item se a quantidade máxima for ultrapassada o programa deve dar uma
mensagem de erro;
\item se for requisitada a remoção de um número não existente o programa
  deve dar uma mensagem de erro;
\item se o código de operação for inválido o programa deve continuar lendo
um novo código até que ele seja 0 (zero), 1 (um) ou 2 (dois).
\end{itemize}

\noindent
{\bf Exemplo de execução: }
\begin{small}
\begin{verbatim}
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 45.3 
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 34.3 
Entre com operacao (0=fim, 1=insercao, 2=remocao): 1 
Valor: 40.8
Entre com operacao (0=fim, 1=insercao, 2=remocao): 2 
Valor: 34.3
Entre com operacao (0=fim, 1=insercao, 2=remocao): 0
Vetor resultante
40.8   45.3 
\end{verbatim}
\end{small}

\begin{center}
\begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|l}
\multicolumn{1}{c}{1} & \multicolumn{1}{c}{2} & \multicolumn{1}{c}{3} & \multicolumn{1}{c}{4} & \multicolumn{1}{c}{5} & \multicolumn{1}{c}{6} & \\ \cline{1-6} 
&&&&&& \mbox{início}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
45.3&&&&&& \mbox{após inserção de 45.3}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
34.3&45.3&&&&& \mbox{após inserção de 34.3}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
34.3&40.8&45.3&&&& \mbox{após inserção de 40.8}\\ \cline{1-6}
\multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \multicolumn{1}{c}{} & \\ \cline{1-6} 
40.8&45.3&&&&& \mbox{após remoção de 34.3}\\ \cline{1-6}
\end{tabular}
\end{center}

\item Escreva um programa 
que leia duas sequências de caracteres e
verifica se a segunda sequência é subpalavra da primeira.
Por exemplo, {\em todo} é subpalavra de {\em metodo} e
{\em ar} é subpalavra de {\em farmacia}.  Porém, {\em todo} não é
subpalavra de {\em todavia}.   A leitura das sequências deve ser feita
caracter por caracter e o final de cada sequência é sinalizada pelo
caracter '.'.    Se a segunda sequência é uma subpalavra, a saída do 
programa deve ser a posição na qual ela começa.  Caso contrário, escrever
a mensagem ``Nao eh subpalavra.''. 
{Observações:} 
\begin{itemize}
\item cada sequência tem no máximo 80 caracteres.
\item você não pode utilizar funções de manipulação de cadeias de
caracteres existentes no compilador, mas somente as funções para o
tipo {\tt char}.
\end{itemize}

\noindent
{Exemplo de execução: }
\small
\begin{verbatim}
Entre com duas palavras terminadas por ponto:
metodo.todo.

A segunda subpalavra comeca na posicao 3 da primeira.
\end{verbatim}



\item Escreva um programa que leia uma sequência de $n$ valores
reais ($n \leq 100$) e os insira num vetor.  A sequência termina quando o
valor lido for 0.  O programa deve escrever o valor da divisão 
da soma dos valores positivos pela soma dos valores
negativos que estão armazenados no vetor. Cuidado com divisões por zero.

\item Escreva uma função em  que substitui em um texto a primeira
ocorrência de  uma   palavra por   outra.  A  função  deve  retornar
\verb+true+ se a subs\-ti\-tui\-ção for bem sucedida e
\verb+false+ caso a palavra  não seja encontrada no  texto.  O texto e
as palavras são  representados  por vetores  do  tipo \verb+char+. Por
exemplo:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+
texto1  | e | x | e | m | p | r | o |   | u | n |
        +---+---+---+---+---+---+---+---+---+---+
          +---+---+---+---+---+
palavra1  | r | o |   | u | n |
          +---+---+---+---+---+
          +---+---+---+---+---+---+---+
palavra2  | l | o |   | d | o | i | s |
          +---+---+---+---+---+---+---+
        +---+---+---+---+---+---+---+---+---+---+---+---+
texto2  | e | x | e | m | p | l | o |   | d | o | i | s |
        +---+---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
\vspace{-0.2cm}
A função recebe como parâmetros o texto, a palavra a ser substituída e
a nova palavra.  No exemplo, \verb+texto1+  mostra o estado inicial do
texto  e \verb+texto2+  o   estado do texto  após  a   substituição da
\verb+palavra1+ pela \verb+palavra2+.

Você pode usar, caso seja necessário, a função:
\begin{center}
\begin{small}
\begin{verbatim}
   buscachar(texto, pos, letra);
\end{verbatim}
\end{small}
\end{center}
que busca  um  caractere (\verb+letra+) a  partir   de uma determinada
posição (\verb+pos+) em um vetor que  contém o texto (\verb+texto+). A
função \verb+buscaletra+  retorna a posição  no  vetor \verb+texto+ da
primeira ocorrência  de  \verb+letra+, se \verb+letra+  não aparece no
texto a função retorna \verb+-1+.

\item Um \emph{algoritmo genético} é um procedimento computacional de busca,
inspirado no processo biológico de  evolução, que otimiza a solução de
um  pro\-ble\-ma.  O   problema é   modelado por: uma    população de
indivíduos que representam possíveis soluções; uma função que avalia a
qualidade da solução representada por cada indivíduo da população e um
conjunto  de operadores  genéticos.   Os   indivíduos  são dados   por
sequências   de genes que   representam características  da solução do
problema.  O procedimento consiste  em aplicar os operadores genéticos
sobre a população, gerando novos indivíduos e selecionar os mais aptos
para  constituirem uma  nova população.  Esse  processo é repetido até
que uma solução adequada seja obtida.  Dentre os operadores genéticos,
o mais importante é  o de recombinação genética  (\emph{crossover}) de
dois indivíduos.  Esse operador corta  em duas partes as sequências de
genes de dois indivíduos pais (\verb+pai1+  e \verb+pai2+) e gera dois
novos   indivíduos    filhos    (\verb+filho1+    e    \verb+filho2+).
\verb+filho1+ é dado pela contatenação da primeira  parte dos genes de
\verb+pai1+  com a segunda parte  de  \verb+pai2+ e \verb+filho2+ pela
concatenação  da primeira parte de \verb+pai2+  com a segunda parte de
\verb+pai1+.  O diagrama abaixo  exemplifica a operação  em indivíduos
representados por vetores de números inteiros  onde a primeira posição
contém o tamanho do vetor:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
                          corte1
        +----+---+---+---#---+---+---+---+---+---+---+---+
pai1    | 11 | 1 | 1 | 1 # 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
        +----+---+---+---#---+---+---+---+---+---+---+---+

                                  corte2
        +----+---+---+---+---+---#---+---+---+---+---+
pai2    | 10 | 3 | 3 | 3 | 3 | 3 # 4 | 4 | 4 | 4 | 4 |
        +----+---+---+---+---+---#---+---+---+---+---+

        +----+---+---+---+---+---+---+---+---+
filho1  |  8 | 1 | 1 | 1 | 4 | 4 | 4 | 4 | 4 |
        +----+---+---+---+---+---+---+---+---+

        +----+---+---+---+---+---+---+---+---+---+---+---+---+---+
filho2  | 13 | 3 | 3 | 3 | 3 | 3 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
        +----+---+---+---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
Escreva um procedimento  em  que   execute a operação   de
recombinação descrita acima, usando  a estrutura de dados vetor.  O
procedimento deve  receber seis parâmetros, um vetor re\-pre\-sentando
o primeiro pai,   a posição  de   corte no   primeiro  pai, um   vetor
re\-pre\-sentando o segundo pai, a posição do corte  no segundo pai, e
dois vetores que receberão os novos indivíduos. No exemplo apresentado
a chamada do procedimento seria:
\vspace{-0.2cm}
\begin{center}
\begin{small}
\begin{verbatim}
   corte1 := 4;
   corte2 := 6;
   crossover(pai1, corte1, pai2, corte2, filho1, filho2);
\end{verbatim}
\end{small}
\end{center}
\vspace{-0.2cm}
Note que os vetores  devem iniciar na   posição zero e essa  posição é
usada para armazenar o tamanho do vetor. No caso do exemplo,
\verb+ pai1[0]=11+, 
\verb+ pai2[0]=10+,
\verb+filho1[0]=8 + e
\verb+ filho2[0]=13+.
Os pontos de corte devem estar dentro dos vetores:
\verb+1 < corte1 <= pai1[0] + e 
\verb+ 1 < corte2 <= pai2[0]+.

\item Escreva um procedimento em  
que implemente a subtração de números
binários. Considere que os números binários têm $N$ bits e que os bits
são armazenados em vetores de inteiros de $N$ posições indexadas de 1 a 
$N$. O primeiro bit do vetor representa o sinal do número, sendo zero (0) 
para o números positivos e um (1) para negativos. Os demais bits 
representam o valor absoluto do número. Por exemplo, para $N=11$, os 
números decimais $-13$, 12 e 1010 são representados pelos seguintes 
vetores:
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+---+
   -13: | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |
        +---+---+---+---+---+---+---+---+---+---+---+

        +---+---+---+---+---+---+---+---+---+---+---+
    12: | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+

        +---+---+---+---+---+---+---+---+---+---+---+
  1010: | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{small}
\end{center}
O procedimento recebe dois vetores do mesmo tamanho como parâmetros e 
deve gerar como resultado um vetor que contenha a subtração do 
primeiro pelo segundo. Por exemplo $-12 - 1010 = -1022$:
\begin{center}
\begin{small}
\begin{verbatim}
        +---+---+---+---+---+---+---+---+---+---+---+ 
  -998: | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 0 |
        +---+---+---+---+---+---+---+---+---+---+---+ 
\end{verbatim}
\end{small}
\end{center}
Caso o resultado tenha mais bits que o espaço disponível no vetor
o procedimento deve descartar os bits excedentes. 

\item Escreva um programa em  
que leia uma sequência de $N$ valores
reais não nulos ($N \leq 100$) e os insira em um vetor.
A sequência termina quando o valor lido for 0. O elemento zero não faz
parte do vetor. Leia do teclado um inteiro $p$ ($p \leq N$) e
considere que o elemento $V[p]$ como o pivô na operação
de rearranjar o vetor de tal maneira que todos os elementos à
esquerda de $V[p]$ sejam menores que ele e todos os da direta sejam
maiores ou iguais a ele. Por exemplo, considere o seguinte vetor dado
como entrada: 
\begin{center}
\begin{small}
\begin{verbatim}
    +------+------+------+------+------+------+------+
    | 99.7 | 32.6 | 2.45 | 13.4 | 26.7 | 12.2 | 0.51 | 
    +------+------+------+------+------+------+------+
\end{verbatim}
\end{small}
\end{center}
e $P$ valendo 3, o programa deve gerar como resultado um vetor onde
todos os elementos que estão à esquerda do valor $2.45$ no vetor sâo menores
que ele, enquanto que os da direita são maiores do que ele.

\item Escreva uma função em  que procura uma palavra dentro
de um texto. A função deve receber como parâmetros:
\begin{itemize}
\item um vetor do tipo \verb+texto+ que contém um texto;
\item o tamanho do vetor que contém o texto;
\item a posição inicial da busca dentro do vetor que contém o 
texto;
\item um vetor do tipo \verb+texto+ que contém uma palavra;
\item o tamanho do vetor que contém a palavra.
\end{itemize}
A função deve retornar um número inteiro indicando a posição
no texto onde a palavra foi encontrada pela primeira vez. 

Caso a palavra não seja encontrada ou algum erro ocorra o 
valor retornado deve ser zero. A busca pela palavra no texto 
deve iniciar na posição passada como parâmetro para a função.

O tipo \verb+texto+ é dado por:
\begin{center}
\begin{small}
\begin{verbatim}
   const
      TAMMAX = 10000;

   type
      texto = array [1..TAMMAX] of char;

\end{verbatim}
\end{small}
\end{center}

\item Escreva um programa em  que gere e imprima um
vetor de números reais de tamanho $N$, $1 \le N \le MAX$. A criação
do vetor deve ser feita da seguinte maneira:
\begin{itemize}
\item O tamanho $N$ do vetor deve ser lido do teclado; 
\item Os $N$ números reais são gerados aleatoriamente no
intervalo $[R_{min},R_{max}[$, com $R_{min}$ e $R_{max}$ lidos do teclado;
\item A posição em que cada elemento real é inserida no vetor também é gerada
      aleatoriamente;
\item Se uma posição $i$ sorteada já estiver ocupada, seu algoritmo deve
encontrar a primeira posição $j$ não ocupada, iniciando a partir de $i+1$ até
o final do vetor. Se todas as posição entre $i+1$ e o final do vetor
estiverem ocupadas, seu algoritmo deve pegar a primeira posição livre a
partir do início do vetor.
\end{itemize}

Dica: a função \verb|random| sem parâmetros retorna um número real no intervalo
$[0,1[$, e a função \verb|random(n)| retorna um número inteiro no intervalo
$[0,n[$.

\item Escreva um procedimento em  que remove um
  elemento de uma determinada posição $p$ de um vetor $v$ de $n$ números
  reais. O vetor não está ordenado. 
  Use a seguinte assinatura para o procedimento: 

\verb!   procedure remove(var v: vetor; var n: integer; p: integer);!


\item Escreva um procedimento em  que altere um
  vetor de $N$ números reais da seguinte forma: todos os elementos
  repetidos do vetor devem ir para o final do vetor, mas de maneira
  que estes últimos fiquem em ordem crescente. Exemplos:

\verb!   ENTRADA: 5 3 8 2 3 9 8 9 7 5 3               ENTRADA: 4 4 3 3 2 2!

\vspace*{-1mm}
\verb!   SAÍDA  : 5 3 8 2 9 7 3 3 5 8 9               SAÍDA  : 4 3 2 2 3 4!

\item Em uma festa estiveram presentes 150 pessoas. Cada uma delas recebeu
um crachá na entrada com um número entre 1 e 150, número que
representa a ordem de entrada de cada convidado.

Como em toda festa, cada um dos presentes cumprimentou outras pessoas
com apertos de mão. Ao final da festa, cada convidado sabia exatamente
quantas vezes tinha apertado a mão de outras pessoas.

Na saída, ao entregar o crachá ao recepcionista, cada convidado
informou o número do seu crachá e quantas vezes trocou apertos de mão
na festa.

Muito curioso, o recepcionista queria saber quantos convidados eram
muito populares no encontro, isto é, queria saber o número de pessoas
que apertaram a mão de pelo menos outros 120 convidados.

Faça um programa
que modele o problema do recepcionista e que produza como saída o
número de celebridades (cumprimentadas pelo menos 120 vezes) presentes
na festa.

\item Um procedimento chamado \texttt{nova\_geracao} 
recebe como parâmetros dois  vetores (origem e  destino) e o
tamanho  dos vetores.  Este  procedimento constrói  um  novo vetor  de
valores  0 ou  1  (destino) a  partir  do conteúdo  do primeiro  vetor
(origem). Seja $O$ o vetor origem e $D$ o vetor destino, a regra para 
a construção do novo vetor é dada por:
\begin{itemize}
\item 
se: $O[i-1] = 0,\ O[i] = 0,\ O[i+1] = 0$ então: $D[i] = 0$
\item 
se: $O[i-1] = 0,\ O[i] = 0,\ O[i+1] = 1$ então: $D[i] = 1$
\item 
se: $O[i-1] = 0,\ O[i] = 1,\ O[i+1] = 0$ então: $D[i] = 1$
\item 
se: $O[i-1] = 0,\ O[i] = 1,\ O[i+1] = 1$ então: $D[i] = 1$
\item 
se: $O[i-1] = 1,\ O[i] = 0,\ O[i+1] = 0$ então: $D[i] = 1$
\item 
se: $O[i-1] = 1,\ O[i] = 0,\ O[i+1] = 1$ então: $D[i] = 0$
\item 
se: $O[i-1] = 1,\ O[i] = 1,\ O[i+1] = 0$ então: $D[i] = 0$
\item 
se: $O[i-1] = 1,\ O[i] = 1,\ O[i+1] = 1$ então: $D[i] = 0$
\end{itemize}
Onde $i$ indica uma posição do vetor $D$. Considere o valor 0 para as
bordas externas do vetor origem $O$. Escreva o procedimento
\texttt{nova\_geracao} e separe a regra descrita acima em uma função
que dados os valores das 3 posições consecutivas do vetor origem
($O[i-1], O[i], O[i+1]$) calcula o valor correspondente no vetor
destino ($D[i]$).

\item Faça um programa em  que simule o 
tráfego em um trecho de uma rodovia de mão única, ou seja, uma rodovia na 
qual os veículos entram de um lado e saem do outro. 

\begin{itemize}
    \item A rodovia é representada por um vetor com \verb|TAM_RODOVIA| posições;
    \item A simulação ocorre durante \verb|MAX_TEMPO| iterações;
    \item Através da chamada do procedimento \\
          \verb|detecta_entrada(VAR tipo, placa, velocidade:INTEGER)|,\\
          o programador é 
          informado sobre a ocorrência ou não da entrada de um veículo na
          rodovia, bem como o tipo do veículo, sua placa e sua respectiva 
          velocidade, onde:
        \begin{itemize}
            \item \emph{tipo:} $0$ - nenhuma nova entrada, 
                               $1$ - entrou automóvel, 
                               $2$ - entrou caminhão;
            \item \emph{placa:} um número inteiro;
            \item \emph{velocidade:} a velocidade de deslocamento do veículo 
                   (em posições/unidade de tempo).
        \end{itemize}
    \item Veículos do tipo automóvel ocupam uma posição da rodovia. 
          Caminhões ocupam duas posições.
    \item Quando veículos mais rápidos alcançam veículos mais lentos, os 
          primeiros devem andar mais devagar, pois não podem ultrapassar.
\end{itemize}    
    

A cada unidade de tempo em que algum veículo sair da rodovia, seu programa
deve imprimir esta unidade de tempo e o número da placa do veículo que saiu.

Exemplo: (\verb|TAM_RODOVIA=7|, \verb|MAX_TEMPO=10|)
\begin{itemize}
    \item Entrada:
    \begin{itemize}
        \item \textbf{t=1:} $tipo=2, placa=35, velocidade=1$
        \item \textbf{t=2:} $tipo=0$
        \item \textbf{t=3:} $tipo=1, placa=27, velocidade=4$
        \item \textbf{t=4:} $tipo=0$
        \item \textbf{t=5:} $tipo=0$
        \item \textbf{t=6:} $tipo=1, placa=16, velocidade=2$
        \item \textbf{t=7:} $tipo=0$
        \item \textbf{t=8:} $tipo=0$
        \item \textbf{t=9:} $tipo=0$
        \item \textbf{t=10:} $tipo=0$
    \end{itemize}

    \item Representação gráfica:

    \begin{itemize}
        \item \textbf{t=1:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $35_1$&$35_1$& & & & &\\ \hline \end{tabular}
        \item \textbf{t=2:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline &$35_1$& $35_1$& & & &\\ \hline \end{tabular}
        \item \textbf{t=3:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $27_4$& & $35_1$&$35_1$ & & &\\ \hline \end{tabular}
        \item \textbf{t=4:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & $27_4$& $35_1$& $35_1$& &\\ \hline \end{tabular}
        \item \textbf{t=5:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & $27_4$& $35_1$& $35_1$&\\ \hline \end{tabular} 
        \item \textbf{t=6:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline $16_2$& & & & $27_4$& $35_1$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=7:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & &$16_2$ & & & $27_4$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=8:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & $16_2$& & $27_4$ \\ \hline \end{tabular}
        \item \textbf{t=9:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & & $16_2$ \\ \hline \end{tabular}
        \item \textbf{t=10:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & & \\ \hline \end{tabular}
    \end{itemize}

    \item Saída:
    \begin{itemize}
        \item \textbf{t=8:} $35$
        \item \textbf{t=9:} $27$
        \item \textbf{t=10:} $16$
    \end{itemize}
\end{itemize}

%\begin{lstlistings}[frame=trBL]
%Code
%\end{lstlistings}


\item Você deve incluir no enunciado da questão anterior a
existência de uma pista de ultrapassagem. Agora, veículos mais rápidos 
podem mover-se para a pista de ultrapassagem ao alcançarem veículos mais 
lentos, desde que não haja ninguém ocupando aquele trecho de pista. 
Eles devem retornar à pista original assim que tiverem completado 
a ultrapassagem, retomando a velocidade original. Você deve escrever unicamente
os procedimentos modificados ou novos que levam em conta este novo fato.

Exemplo da nova saída para a entrada original:
\begin{itemize}
    \item Representação gráfica:
    \begin{itemize}
        \item \textbf{t=1:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\
            \hline $35_1$&$35_1$& & & & &\\ \hline \end{tabular}
        \item \textbf{t=2:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline &$35_1$& $35_1$& & & &\\ \hline \end{tabular}
        \item \textbf{t=3:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline $27_4$& & $35_1$&$35_1$ & & &\\ \hline \end{tabular}
        \item \textbf{t=4:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & $27_4$& & &\\ 
            \hline & & & $35_1$& $35_1$& &\\ \hline \end{tabular}
        \item \textbf{t=5:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & $35_1$& $35_1$&$27_4$\\ \hline \end{tabular} 
        \item \textbf{t=6:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline $16_2$& & & & & $35_1$& $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=7:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & &$16_2$ & & & & $35_1$ \\ \hline \end{tabular} 
        \item \textbf{t=8:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & $16_2$& &  \\ \hline \end{tabular}
        \item \textbf{t=9:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & & & $16_2$ \\ \hline \end{tabular}
        \item \textbf{t=10:} \begin{tabular}{|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|p{1cm}|}
            \hline & & & & & &\\ 
            \hline & & & & & & \\ \hline \end{tabular}
    \end{itemize}
    \item Saída:
    \begin{itemize}
        \item \textbf{t=6:} $27$
        \item \textbf{t=8:} $35$
        \item \textbf{t=10:} $16$
    \end{itemize}
\end{itemize}


\item Mateus, um engenheiro novato, está desenvolvendo uma notação posicional original
para representação de números inteiros. Ele chamou esta notação de UMC 
(Um método curioso). A notação UMC usa os mesmos dígitos da notação decimal,
isto é, de 0 a 9.
%
Para converter um número $A$ da notação UMC para a notação decimal deve-se
adicionar $K$ termos, onde $K$ é o número de dígitos de $A$ (na notação UMC).
O valor do $i$-ésimo termo correspondente ao $i$-ésimo dígito $a_i$, contando
da direita para a esquerda é $a_i \times i!$. 

Por exemplo, 719$_{UMC}$ é equivalente a 53$_{10}$, pois
$7 \times 3! + 1 \times 2! + 9 \times 1! = 53$.

Mateus está começando seus estudos em teoria dos números e 
provavelmente não sabe quais as propriedades que um sistema de numeração
deve ter, mas neste momento ele está interessado em converter
os números da notação UCM para a notação decimal. Você pode ajudá-lo?

\noindent
\textbf{Entrada}:
cada caso de teste é fornecido em uma linha simples que contém um 
número não vazio de no máximo 5 dígitos, representando um número 
em notação UMC. Este número não contém zeros a esquerda. O último
teste é sequido por uma linha contendo um zero.

\noindent
\textbf{Saída}:
para cada caso de teste imprimir uma linha simples contendo a representação
em notação decimal do correspondente número em UMC seguido do cálculo feito
para a conversão.

\noindent
\textbf{O programa}:
seu programa deve, para cada número da entrada, convertê-lo em um vetor
de inteiros, sendo que cada dígito do número é um elemento do vetor,
e fazer os cálculos usando este vetor. 

\noindent
Exemplos de entrada e saída:
\begin{verbatim}
ENTRADA                SAÍDA
719                    53 = 7 x 3! + 1 x 2! + 9 x 1!
1                      1 = 1 x 1!
15                     7 = 1 x 2! + 5 x 1!
110                    8 = 1 x 3! + 1 x 2! + 0 x 1!
102                    8 = 1 x 3! + 0 x 2! + 2 x 1!
0 
\end{verbatim}


\item Sabemos que nos compiladores  mais recentes, nos
  quais existe o tipo \textsf{string}, podemos realizar de maneira simples
   operações com  palavras.  Imagine, no entanto, que  estamos usando um
  compilador  \emph{Pascal}  no  qual  não  existe  este  tipo.  Neste  caso  o
  programador deve  implementar por  sua própria conta  os procedimentos
  com palavras. Neste exercício iremos considerar a seguinte 
  declaração alternativa para o tipo \textsf{string}: \\
\begin{center}
\verb+type palavra = array[1..MaxTam] of char;+ 
\end{center}
  Implemente uma função em \emph{Pascal} que receba
  como parâmetros duas variáveis do tipo \textsf{MeuString} e retorne -1 se a
  primeira palavra for lexicograficamente menor que a segunda, 0 se
  forem iguais, e +1 no caso que resta.



\item Faça um programa que leia um certo número indefinido de
vetores e que imprima o vetor original (O) e um vetor gerado (G)
após um processo de compactação
que consiste na eliminação de todos os elementos repetidos
em cada vetor. Considere que a entrada de dados é feita em
um vetor por linha, sendo que o primeiro elemento da linha é
o tamanho de cada vetor e os elementos restantes da linha são
os elementos do vetor. Quando o tamanho for zero significa que 
terminou a entrada de dados. Por exemplo, considere a seguinte
entrada:

\begin{verbatim}
5 2 4 7 -1 2
3 1 1 1 
7 3 4 5 3 4 5 1
0
\end{verbatim}

Deverá produzir como saída o seguinte:

\begin{verbatim}
O: 2 4 7 -1 2
G: 2 4 7 -1
O: 1 1 1
G: 1
O: 3 4 5 3 4 5 1
G: 3 4 5 1
\end{verbatim}

\item Considere uma sequência de dígitos binários como:

011100011

Uma maneira de criptografar essa sequência de bits é adicionar
à cada dígito a soma dos seus dígitos adjacentes. Por exemplo,
a sequência acima se tornaria:

123210122

Se $P$ é a sequência original e $Q$ é a sequência criptografada,
então $Q[i] = P[i-1] + P[i] + P[i+1]$ para todas as posições $i$
da sequência. Considerando uma sequência de tamanho $n$ e seus
índices variando de $0$ a $n-1$, os dígitos $P[-1]$ e $P[n]$ não
fazem parte da sequência original e são tratados como zeros na
operação de codificação.

Assumindo $P[0] = 0$ temos:
\begin{itemize}
\item
$Q[0] = P[0] + P[1] = 0 + P[1] = 1$, logo $P[1] = 1$.
\item
$Q[1] = P[0] + P[1] + P[2] = 0 + 1 + P[2] = 2$, logo $P[2] = 1$.
\item
$Q[2] = P[1] + P[2] + P[3] = 1 + 1 + P[3] = 3$, logo $P[3] = 1$.
\item
Repetindo a operação temos: $P[4] = 0$, $P[5] = 0$, $P[6] = 0$, $P[7] = 1$ e $P[8] = 1$.
\end{itemize}

Agora repetindo o mesmo processo para $P[0] = 1$ temos:
\begin{itemize}
\item
$Q[0] = P[0] + P[1] = 1 + P[1] = 1$, logo $P[1] = 0$.
\item
$Q[1] = P[0] + P[1] + P[2] = 1 + 0 + P[2] = 2$, logo $P[2] = 1$.
\item
$Q[2] = P[1] + P[2] + P[3] = 0 + 1 + P[3] = 3$, o que nos leva a conclusão que $P[3] = 2$.
Entretanto isso viola o fato da sequência original ser binária. Portanto não
existe uma decodificação possível considerando o primeiro dígito da sequência original
valendo $1$.
\end{itemize}
Note que este algoritmo pode gerar ou decodificar uma sequência criptografada em até duas 
possíveis sequências originais, uma iniciando com 0 e outra iniciando com 1.

Escreva um procedimento em  que receba como parâmetros um vetor de
números inteiros contendo a sequência criptografada e a decodifica em dois outros
vetores de números inteiros. Caso uma das decodificações não seja possível, como
no caso do exemplo para $P[0] = 1$, o vetor correspondente deve ser preenchido com -1
na posição inicial.

Outros exemplos:
\begin{itemize}
\item
$123210122 = 011100011, -1$
\item
$11 = 01, 10$
\item
$22111 = -1, 11001$
\item
$123210120 = -1, -1$
\item
$3 = -1, -1$
\item
$12221112222221112221111111112221111 = \\
01101001101101001101001001001101001, \\
10110010110110010110010010010110010$
\end{itemize}

\item Escrever um programa para ler um texto e imprimir uma distribuição de
   frequências para  palavras do texto  (quantas palavras de  uma letra,
   quantas de duas letras, etc.).


\item Escreva um programa em \emph{Pascal} que leia do teclado o gabarito de uma prova
de 20 questões de múltipla escolha, onde as respostas são inteiros de 1 a
5.  Em seguida, o programa deve ler o número de alunos que prestaram a prova
e, para cada aluno, a sua matrícula (um inteiro) e as respectivas respostas.
O programa deve calcular e escrever:
\begin{itemize}
\item a relação de alunos ordenados pela nota, supondo que cada questão vale 5 pontos;
\item para cada questão: quantos alunos acertaram a questão
\end{itemize}




\end{enumerate}
